---
title : "对深入理解java虚拟机的读书总结"
date: 2019-03-24T01:37:56+08:00
lastmod: 2019-03-25T01:37:56+08:00
draft: false
tags: ["Java", "JVM"]
categories: ["Java fundemental knowledge"]
author: "Yang Zhang"
---

# Part 1(Java 概括)
**Java技术体系的组成部分**
- Java 程序设计语言
- 各种硬件平台上的Java虚拟机
- Class文件格式
- Java API 类库
- 来自商业机构和开源社区的第三方Java类库

**JDK(Java Development Kit)**
包括Java 程序设计语言, Java虚拟机, JavaAPI类库这三部分。是用于支持Java程序开发的最小环境

**JRE(Java Runtime Environment)**
包括Java SE API子集和Java虚拟机这两个部分。是支持Java程序运行的标准环境。

**Java的四个平台**
- Java Card: 支持一些Java小程序(Applets) 运行在小内存设备（如智能卡）上的平台
- Java ME(Micro Edition): 支持Java程序运行在移动终端上的平台，是对Java API有所精简并加入了针对移动终端支持，以前称为J2ME。
- Java SE（Standard Edition）: 支持面向桌面级应用。
- Java EE (Enterprise Edition) : 支持使用多层架构的企业应用的Java平台，除了提供Java SE API外，还对其做了大量的扩充和部署支持。

# Part 2（自动内存管理机制）
## Java内存区域与内存溢出异常
### 运行时的数据区域
Java虚拟机在执行Java程序的过程中会把所管理的内存划分为若干个不同的数据区域.
![数据区](/media/posts/dataArea.png)
1. **程序计数器(Program Counter Register)**
    * 当前线程所执行的字节码的行号指示器
    * 字节码解释器工作时通过**程序计数器**来选取下一条需要执行的字节码指令.
    * 每个线程都需要一个独立的程序计数器,各条线程之间的计数器互不影响,独立存储.称这类内存区域为"线程私有"的内存
    * 若线程正在执行java方法,则**程序计数器**记录正在执行的虚拟机字节码指令的地址.若执行的是Native方法,则这个计数器值为空(Undefined).
    * 此内存是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域.
        > Native方法
        > "A native method is a Java method whose implementation is provided by non-java code."
        > 使用Native Method的原因 1.需要与java环境外交互2.需要与操作系统交互

2. **Java虚拟机栈(Java Virtual Machine Stacks)**
    * **Java虚拟机栈**也是线程私有的.
    * **Java虚拟机栈**描述的是Java方法执行的内存模型: 每个方法在执行的同时会创建一个栈帧(Stack Frame)用于存储局部变量表,操作数栈,动态链接,方法出口等信息.每一个方法从调用直到执行完成的过程就对应着一个栈帧在虚拟机栈中入栈到出栈的过程.
    * 局部变量表所需的内存空间在编译时完成分配,当进入一个方法时,这个方法需要在帧中分配多大的局部变量空间是完全确定的
    * 如果线程请求的栈深度大于虚拟机所允许的深度,将抛出StackOverFlowError异常.
    * 虚拟机栈动态扩展的过程中,如果扩展时无法申请到足够的内存,就会抛出OutOfMemoryError异常.

3. **本地方法栈(Native Method Stack)**
    * **本地方法栈**类似于**Java虚拟机栈**. 前者为Native Method服务,后者为Java方法(字节码)服务.

4. **Java堆(Java Heap)**
    * 对大多数应用来说, Java Heap是Java虚拟机所管理的内存中最大的一块, 并被所有线程共有. 在虚拟机启动时就已创建.
    * 此内存区域的唯一目的就是存放对象实例,几乎所有的对象实例都在这里分配内存(Java虚拟机规范: 所有的对象实例以及数组都要在堆上分配.)
    * JIT编译器的发展与逃逸分析技术逐渐成熟, 栈上分配,标量替换优化技术会导致一些微妙的变化.上述第二点描述变得并不绝对.
        > Java程序最初是仅仅通过解释器解释执行的，即对字节码逐条解释执行，这种方式的执行速度相对会比较慢，尤其当某个方法或代码块运行的特别频繁时，这种方式的执行效率就显得很低。于是后来在虚拟机中引入了JIT编译器（即时编译器），当虚拟机发现某个方法或代码块运行特别频繁时，就会把这些代码认定为“Hot Spot Code”（热点代码），为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各层次的优化 (摘自https://blog.csdn.net/ns_code/article/details/18009455)

        > **逃逸分析(Escape Analysis)**的基本行为就是分析对象动态作用域：当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他地方中，称为方法逃逸。如果能证明一个对象不会逃逸到方法或线程外，则可能为这个变量进行一些高效的优化。如果能够通过逃逸分析确定某些对象不会逃出方法之外，那就可以让这个对象在栈上分配内存，这样该对象所占用的内存空间就可以随栈帧出栈而销毁，就减轻了垃圾回收的压力。在一般应用中，如果不会逃逸的局部对象所占的比例很大，如果能使用栈上分配，那大量的对象就会随着方法的结束而自动销毁了。
    * Java堆是垃圾收集器管理的主要区域. 因此很多时候也被称为GC堆.
    * Java堆可以处于物理上不连续的内存空间中,只要逻辑上连续的即可(//TODO: 是否与虚存相关?)
    * 如果在堆中没有内存完成实例分配, 并且堆也无法再扩展时, 将会抛出OutOfMemoryError.
    
5. **方法区(Method Area)**
   * **方法区**与Java堆一样都是所有线程共享的内存区域.它用于存储已被虚拟机加载的类信息,常量,静态变量,即时编译器编译后的代码等数据.别名Non-Heap.
   * 这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载.
6. **运行时常量池(Runtime Constant Pool)**
   * **运行时常量池**是方法区中的一部分. Class文件中出了有类的版本,字段,方法,借口等描述信息外,还有一项信息是常量池.
7. **直接内存(Direct Memory)**
    * **直接内存**并不是虚拟机运行时数据区的一部分,也不是Java虚拟机规范中定义的内存区域.但是这部分内存也被频繁的使用.而且也可能导致OutOfMemoryError异常出现.
    * JDK1.4中新加入NIO(New Input/Output)类, 引入基于Channel与Buffer的I/O方式.这个类就用到**直接内存**避免数据在Java堆和Native堆中来回复制数据,让其在一些场景中显著提高性能.

### 对象的创建流程(new)
当虚拟机遇到一条new指令时,
1. 检查这个指令的参数是否能在常量池中定位到一个类的符号引用.并检查这个符号引用代表的类是否已经被加载,解析和初始化过.如果没有,那必须先执行相应的类加载过程.

2. 在类加载检查通过后,接下来虚拟机将为新生对象分配内存. 对象所需内存的大小在类加载完成后便可完全确定,为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来.
    * **指针碰撞(Bump the Pointer)**把分界点的指针向空闲空间那边挪动一段与对象大小相等的距离        ---Serial, ParNew
    * **空闲列表(Free List)** 更新记录可用内存块的列表  ---CMS

3. 内存分配完成后,虚拟机需要将分配到的内存空间都初始化为零值(不包括对象头).这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用,程序能访问到这些字段的数据类型所对应的零值.
4. 虚拟机对对象进行一些必要的设置
   * 这个对象是哪个类的实例
   * 如何才能找到类的元数据信息
   * 对象的hashcode
   * 对象的GC分代年龄等信息

5. 结束后以上工作后,从虚拟机的视角看,一个新的对象已经产生了,但从Java程序的视角看,对象的创建才刚刚开始--init方法还没有执行,所有字段依旧为零值
6. 接着执行init方法, 把对象按照程序员的意愿进行初始化,这样一个真正可用的对象才算完全产生出来.

### 对象的内存布局
对象在内存中存储的布局可以分为3块区域: 对象头(Header), 实例数据(Instance Data), 和对齐填充(Padding)
1. **对象头(Header)**包括两部分
   * 自身的运行时数据 -hashcode, GC分代年龄, 锁状态标志, 线程持有的锁, 偏向线程ID, 偏向时间戳
   * 类型指针, 即对象指向它的类元数据的指针,虚拟机同过其来确定这个对象是哪个类的实例.
2. **实例数据**是对象真正存储的有效信息,也是在程序代码中所定义的各种类型的字段内容
3. **对齐填充**因对象的大小必须是8字节的整数倍,没对齐是用其来填充.

### 对象的访问定位
1. **句柄访问**在对象移动时只需要改变句柄中的实例数据指针,reference本身无需修改
![state access](/media/posts/access_ref.png)
2. **直接指针访问**速度更快,它节省了一次指针定位的开销
![direct pointer access](/media/posts/access_direct.png)

## 垃圾收集器(GC)与内存分配策略
### 判断对象是否可以被回收的算法
1. **引用计数算法**
> 给对象中添加一个引用计数器，每当有一个地方引用它时，计数器+1；当引用失效时，计数器就减1；任意时刻计数器为0的对象就是不可能再被使用的。
大部分情况下这是一个不错的算法，但是最大的问题是它很难解决对象之间的互相循环引用的问题。
```Java
public class ReferenceCountingGC{
    public Object instance = null;
    private static final int _1MB = 1024*1024
    private byte[] bigsize = new byte[2* _1MB]

    public static void testGC() {
        ReferenceCountingGC objA = new ReferenceCountingGC();
        ReferenceCountingGC objB = new ReferenceCountingGC();
        objA = null;
        objB = null;
        //即使两个对象相互引用,Java的GC也把两个对象回收了
        System.gc();
    }
}
```
2. **可达性分析算法**
> 这个算法的基本思想就是通过一系列的称为"GC Roots"的对象作为起始点,从这些节点开始向下搜索,搜索所走过的路径称为引用链(Reference Chain),当一个对象到GC Roots没有任何引用链相连时,则证明此对象是不可用的.
![Reachable analysis](/media/posts/reachable.PNG)

3. **对引用更多的定义**
> 初步的定义: 如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址,就称这块内存代表着一个引用.
但是我们需要描述一些"当内存空间还够时则保留在内存中,若进行了垃圾收集后还是非常紧张,则可以抛弃这些对象."的引用.于是引用的概念被扩充至四个, 强引用,软引用,弱引用和虚引用.
   - **强引用**: 只要强引用还在,垃圾收集器就永远不会收掉被引用的对象.例如Object obj = new Object()这类的引用.
   - **软引用**: 还有用但非必须的对象. 对于软引用关联着的对象, 在系统将要发生内存溢出异常之前,将会把这些对象列进回收范围之中,进行第二次回收. 若这次回收后还没有足够的内存则抛出内存溢出的异常. SoftReference类来实现.
   - **弱引用**: 弱引用的强度比软引用更弱, 被弱引用关联的对象只能生存到下一次垃圾收集发生之前.当垃圾收集器工作时, 无论当前内存是否足够, 都会回收掉只被弱引用关联的对象. WeakReference类来实现
   - **虚引用**: 最弱的引用关系, 为一个对象设置虚引用唯一的目的就是能在这个对象被收集器回收时收到一个系统通知. PhantomReference类来实现.

4. **对象回收前的工作**
要真正宣告一个对象死亡, 至少需要经历两次标记过程: 如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链, 那它将会被第一次标记并且进行一次筛选, 筛选的条件是此对象是否有必要执行finalize()方法, 当对象没有覆盖finalize()方法, 或者finalize()方法已经被虚拟机调用过,虚拟机将这两种情况都视为"没有必要执行".

```Java
public class FinalizeEscapeGC {
    public static FinalizeEscapeGC SAVE_HOOK = null;

    public void isAlive() {
        System.out.println("yes, i'm still alive:)");
    }

    @Override
    protected void finalize() throws Throwable{
        super.finalize();
        System.out.println("finalize method executed!");
        FinalizeEscapeGC.SAVE_HOOK = this;
    }

    public static void main(String[] args) throws Throwable {
        SAVE_HOOK = new FinalizerEscapeGC();
        //第一次自救
        SAVE_HOOK = null;
        System.gc();
        //finalize方法优先级很低,所以暂停0.5秒
        Thread.sleep(500);
        if (SAVE_HOOK != null){
            SAVE_HOOK.isAlive();
        } else {
            System.out.println("no, i'm dead :(");
        }

        //下面与上面完全相同,但是自救失败
        SAVE_HOOK = null;
        System.gc();
        //finalize方法优先级很低,所以暂停0.5秒
        Thread.sleep(500);
        if (SAVE_HOOK != null){
            SAVE_HOOK.isAlive();
        } else {
            System.out.println("no, i'm dead :(");
        }
    }
}
```
5. **回收方法区**
    - **回收废弃常量**: 与回收Java堆中的对象非常类似. 
    - **回收无用的类**: 判断"无用类"的三个条件
        * 该类所有的实例都已经被回收, 也就是Java堆中不存在该类的任何实例
        * 加载该类的ClassLoader已经被回收
        * 该类对应的java.lang.Class对象没有在任何地方被引用, 无法在任何地方通过反射访问该类的方法.

### 垃圾回收算法
介绍垃圾回收算法之前需要先明白Java堆的新生代和老年代
> 在 Java 中，堆被划分成两个不同的区域：年轻代(Young)、老年代 (Tenured).
> 
> 年轻代 ( Young ) 又被划分为三个区域：Eden、From Survivor、To Survivor。 这样划分的目的是为了使 JVM 能够更好的管理堆内存中的对象，包括内存的分配以及回收。
> 
> 堆大小 = 年轻代 + 老年代
> 
> 年轻代 = eden space (新生代) + from survivor + to survivor

![java-heap](/media/posts/javaheap.JPG)

年轻代的特点是产生大量的死亡对象,并且要是产生连续可用的空间, 所以使用复制清除算法和并行收集器进行垃圾回收.对年轻代的垃圾回收称作初级回收 (minor gc)

新生代几乎是所有 Java 对象出生的地方，即 Java 对象申请的内存以及存放都是在这个地方。Java 中的大部分对象通常不需长久存活，具有朝生夕灭的性质。 

当一个对象被判定为 "死亡" 的时候，GC 就有责任来回收掉这部分对象的内存空间。新生代是 GC 收集垃圾的频繁区域。 当对象在 Eden 出生后，在经过一次 Minor GC 后，如果对象还存活，并且能够被另外一块 Survivor 区域所容纳，则使用复制算法将这些仍然还存活的对象复制到另外一块 Survivor 区域中，然后清理所使用过的 Eden 以及 Survivor 区域，并且将这些对象的年龄设置为1，以后对象在 Survivor 区每熬过一次 Minor GC，就将对象的年龄 + 1，当对象的年龄达到某个值时 ( 默认是 15 岁，可以通过参数 -XX:MaxTenuringThreshold 来设定 )，这些对象就会成为老年代。 
但这也不是一定的，对于一些较大的对象 ( 即需要分配一块较大的连续内存空间 ) 则是直接进入到老年代。
(摘自https://gblog.sherlocky.com/java-xin-sheng-dai-lao-nian-dai/)
1. **标记-清除算法(Mark-Sweep)**
   算法分为"标记"和"清除"两个阶段:首先标记出所有需要回收的对象, 在标记完成后统一回收所有被标记的对象. 它时最基础的收集算法.不足有二
   * 效率问题: 标记和清除两个过程效率都不高
   * 空间问题: 标记清除之后会产生大量的不连续的内存碎片,空间碎片太多可能会导致以后再程勋运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾回收动作.
   ![mark-sweep](/media/posts/marksweep.JPG)
2. **复制算法(Copying)**
   此算法为了解决效率问题而产生. 它将可用内存按照容量划分成大小相等的两块, 每次只使用其中的一块.当一块用完时,就将还存活的对象都复制到另一块,然后把已使用过得内存空间一次全部清理掉. 这种算法不用考虑内存碎片等复杂情况但代价是将内存缩小为了原来的一半. 这种算法多用于新生代中的对象的回收.
   ![copying](/media/posts/copying.JPG)
3. **标记-整理算法(Mark-Compact)**
   复制算法并不适用于老年代的对象. 因此出现了**标记-整理算法**, 标记过程与标记-清除算法一样, 但后续会让所有存活的对象都向一端移动, 然后直接清理掉端界面以外的内存.
   ![mark-compact](/media/posts/markcompact.JPG)
4. **分代收集算法(Generational Collection)**
   当前商业虚拟机的垃圾收集都采用**分代收集算法**, 它根据对象存活周期的不同将内存划分为几块, 一般是把Java堆分成新生代和老年代.在新生代中,每次垃圾收集时都发现有大批的对象死去, 只有少量存活,就选用复制算法.而老年代中因为对象存活率高,没有额外空间对他进行分配担保,就要使用**标记-清理**或者**标记-整理**算法.

### 垃圾收集器
HotSpot虚拟机的垃圾收集器如图所示
![GC_HotSpot](/media/posts/GCmachine.JPG)
图中展示了七种不同分代的收集器, 如果两个收集器之间存在连线,说明他们可以搭配使用. 虚拟机所处的区域表示它属于新生代还是老年代的收集器.
1. **Serial收集器**
    ![Serial](/media/posts/serial.JPG)
    * 这是最基本的收集器, 单线程. 并且"单线程"的意义不仅仅说明他只会使用一个CPU或一条收集线程去完成垃圾收集工作,更重要的是它在进行垃圾收集时,必须暂停其他所有的工作线程,直到它收集结束. ---"Stop The World"
    * 这项工作是自动发起和完成的,在用户不可见的情况下把正常工作的线程全部停掉.
    * 简单而高效,对于运行在Client模式下的虚拟机来说是一个很好的选择.
2. **ParNew收集器**
    ![ParNew](/media/posts/parnew.JPG)
    * 其实只是Serial收集器的多线程版本.
    * 是运行在Server模式下的虚拟机中首选的新生代收集器,因为这是目前唯一能和CMS收集器配合工作的新生代收集器.
    * ParNew收集器在单CPU环境中绝不会有比Serial收集器更好的效果

3. **Parallel Scavenge收集器**
    * 与ParNew一样,他也是新生代收集器,使用复制算法,也是并行的多线程
    * Parallel Scavenge收集器的目的是达到一个可控制的吞吐量(Throughput)=>CPU用于运行用户代码的时间与CPU总消耗时间的比值=>吞吐量=运行用户代码的时间/(运行用户代码的时间 + 垃圾回收收集时间)
    * 也被称为"吞吐量优先"收集器
    * 参数: MaxGCPauseMillis控制最大垃圾收集停顿时间, GCTimeRatio设置吞吐量大小, UseAdaptiveSizePolicy开启GC自适应调节策略(GC Ergonomics)
    
4. **Serial Old 收集器**
    * Serial收集器的老年代版本
    * 用来与Parallel Scavenge收集器搭配使用
    * 用来作为CMS收集器的后备预案

5. **Parallel Old 收集器**
    ![Parallel Old](/media/posts/parallelold.JPG)
    * **Parallel Old 收集器**是Parallel Scavenge收集器的老年代版本
    * 在**Parallel Old 收集器**出现之前, 新生代的Parallel Scavenge收集器一直处在比较尴尬的位置由于其无法与CMS收集器配合工作
    * "吞吐量优先"收集器终于有了比较给力的应用组合,在注重吞吐量以及CPU资源敏感的场合,都可以优先考虑Parallel Scavenge加Parallel Old收集器.

6. **CMS 收集器**
    > CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器. 从名字上看CMS收集器是基于"标记-清除"算法实现的.

    它的运作过程相对于前面几种收集器来说更复杂一些,整个过程分为4个步骤.
    + 初始标记(CMS initial mark)
    + 并发标记(CMS concurrent mark)
    + 重新标记(CMS remark)
    + 并发清除(CMS concurrent sweep)

    其中,初始标记和重新标记这两个步骤仍然需要"Stop The World". 
    * 初始标记仅仅只是标记一下GC Roots能关联到的对象,速度很快
    * 并发标记阶段就是进行GC Roots Tracing的过程
    * 重新标记阶段是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录, 这个阶段的停顿时间一般会比初始标记阶段稍长一些, 但远比并发标记的时间段.
    
    ![cms](/media/posts/cms.JPG)
    虽然CMS有并发收集和低停顿的优点,但也具有三个明显的缺点. (//TODO: 详细阐述三个缺点)
    - CMS收集器对CPU资源非常敏感
    - CMS收集器无法处理浮动垃圾(Floating Garbage)
    - CMS基于"标记-清除"算法,意味着它收集结束时会有大量的空间碎片产生.
7. **G1收集器(Garbage-First)**
   * 是一款面向服务端应用的垃圾收集器.
   * 特点是并发与并行,分代收集,空间整合,可预测的停顿
   * 步骤类似CMS,分别为初始标记,并发标记,最终标记,筛选回收
## 虚拟机性能监控与故障处理工具
## 调优案例分析
### 书中实战: 优化Elipse启动时间

# 虚拟机执行子系统
## 类文件结构
### 平台无关性
对于Java来说,平台无关性的基石就是**字节码(Byte Code)**.实现语言无关性的基础是**虚拟机**和**字节码存储格式**.**Java虚拟机**不与任何语言绑定, 它只与"Class文件"这种特定的二进制文件格式所关联.
>Class文件中包含了Java虚拟机指令集和符号表以及若干其他辅助信息. 基于安全方面的考虑, Java虚拟机规范要求在Class文件中使用许多强制性的语法和结构化约束.虚拟机并不关心Class的来源是何种语言

Java语言中的各种变量,关键字,运算符号的语义最终都是由多条字节码命令组成的,因此字节码能够提供的语义描述能力一定比Java本身更加强大.
### Class文件的结构
#### 总述
**Class文件**是一组以8字节为基础单位的二进制流,各个数据项目严格按照顺序紧凑地排列在class文件中,没有任何分隔符.当遇到需要占用8位字节以上空间的数据项时,则会按照高位在前的方式分割成若干个8位字节进行存储.
>**高位存储(Big-Endian)**:具体指最高位字节在地址最低位,最低位字节在地址最高位的顺序来存储数据

根据Java虚拟机规范的规定,class文件格式采用一种类似于C语言结构体的伪结构来存储数据,这种伪结构中只有两种数据类型:**无符号数**和**表**
>**无符号数**:属于基本的数据类型, 以u1, u2, u4, u8来分别代表1,2,4,8个字节的无符号数.无符号数可以用来描述数字,索引引用,数量值或者按照utf-8编码构成的字符串值.

>**表**:是由多个无符号数或者其他表作为数据项构成的复合数据类型, 所有表都习惯性地以"_info"结尾.表用于描述有层次关系的复杂结构的数据, 整个class文件本质上就是一张表.

无论是无符号数还是表,当需要描述同一类型但数量不定的多个数据时,经常会使用一个前置的容量计数器加若干个连续的数据项的形式,这时称这一系列连续的某一类型的数据为某一类型的集合


+ **魔数**: 每个class文件的头四个字节称为**魔数(Magic Number)**,它唯一的作用就是确定这个文件是否为一个能被虚拟机接受的Class文件. 值为0xCAFEBABY.
+ 紧接着魔数的四个字节是**版本号**.5,6字节对应次版本号(Minor Version), 7,8字节对应主版本号(Major Version)
+ 接着是**常量池**入口.常量池可以理解为Class文件中的资源仓库.
    - 它是与Class文件结构中与其他项目关联最多的数据类型
    - 是占用Class文件空间最大的数据项目之一
    - 同时它还是在Class文件中第一个出现的表类型数据项目.

    由于常量池中常量的数量是不确定的, 所以在入口需要放置一项u2类型的数据,代表常量池容量计数器(constant_pool_count).

    常量池中主要存放两大类常量: **字面量(Literal) **和**符号引用(Symbolic References)**. 字面量类似于Java语言层面的常量的概念, 如文本字符串, 声明为final的常量值等.而符号引用则属于编译原理方面的概念.
    - 类和接口的全限定名(Fully Qualified Name)
    - 字段的名称和描述符(Descriptor)
    - 方法的名称和描述符 
    
    > 虚拟机加载Class文件的时候进行动态连接.也就是说,在Class文件中不会保存各个方法,字段的最终内存布局信息,因此这些字段,方法的符号引用不经过运行期转换的话无法得到真正的内存入口地址,也就无法直接被虚拟机使用.当虚拟机运行时,需要从常量池获取对应的符号引用,再在类创建时或运行时解析,翻译到具体的内存地址中.

    常量池中每一项常量都是一个表,表的开始的第一位是一个u1类型的标志位,代表当前这个常量属于哪个常量类型.
    
+ **访问标志(access_flags)**, 这个标志用于识别一些类或者接口层次的访问信息.
    - class是类还是接口
    - 是否定义public类型
    - 是否定义abstract类型
    - 是否被声明为final等
  
  访问标志(access_flags)一共有16个标识符,当前定义了八个,其余标志位要求一致为0.

+ **类索引(this_class), 父索引(super_class), 与接口索引集合(interfaces)**
  - 类索引和父类索引引用两个u2类型的索引值来表示,它们各自指向一个类型为CONSTANT_Class_info的类描述常量.通过其索引值可以找到定义在CONSTANT_Utf8_info类型的常量中的全限定名字符串.
  - 对于接口索引集合,入口第一项为u2类型的数据为接口计数器(interfaces_count),表示索引表的容量.

+ **字段表(field_info)** 用于描述接口或者类中声明的变量.**字段(field)**包括*类级变量*以及*实例级变量*
  - access_flags: 字段修饰符
  - name_index: 字段的简单名称的引用(引常量池)
    > 全限定名: 例如"org/fenixsoft/clazz/TestClass"是一个类的全限定名,仅仅是把类全名中的'.'换成了'/',最后会加一个';'表示全限定名的结束

    > 简单名称: 指没有类型和参数修饰的方法或者字段名称, 例如inc()方法的简单名称就是inc
  - descriptor_index: 字段和方法的描述符: 用来描述字段的数据类型,方法的参数列表(包括数量,类型以及顺序)和返回值
  
  这三项是固定数据项目,不过在descriptor_index之后跟随着一个属性表(attribute_info)集合用于存储一些额外的信息, **字段**都可以在属性表集合中描述零至多项的额外信息
+ **方法表集合**: Class文件存储格式中对方法的描述与对字段的描述几乎采用了完全一致的方式, 结构依次是
  - 访问标志(access_flags)
  - 名称索引(name_index)
  - 描述符索引(descriptor_index)
  - 属性表集合(attributes)
  
  方法里的Java代码经过编译器编译成字节码指令后,存放在方法属性表集合中一个名为"Code"的属性里
  > 这里引出了Java语言中的重载(Override)机制. 重载需要满足两个条件,其一是要与原方法具有相同的简单名称,其二是必须拥有一个与原方法不同的**特征签名**,**特征签名**就是一个方法中各个参数在常量池中的字段符号引用的集合.

  >也正是因为返回值不会包含在特征签名中,因此Java语言里面是无法仅仅依靠返回值的不同来对一个方法进行重载的. 但是在Class文件中,只要描述符不是完全一致的两个方法也可以共存, 因此只有返回值不同的两个方法在同一个Class文件中共同存在是合法的.

+ **属性表集合**
  属性表(attribute_info)存在于字段表和方法表的内部. 对于每一个属性,它的名称都需要偶从常量池中引用一个CONSTANT_Utf8_info类型的常量来表示, 而属性值结构则完全是自定义的,只需要通过一个u4长度属性区说明属性值所占用的位数即可. 以下列举一些常见的属性.
  - Code属性
  - Exception属性
  - LineNumberTable属性
  - LocalVariableTable属性
  - SourceFile属性
### 字节码指令
字节码指令是由一个字节长度的,代表某种特定操作含义的数字以及跟随其后的零至多个代表此操作所需参数而构成. 由于Java虚拟机采用面向操作数栈而不是寄存器的架构,所以大多数的指令都不包含操作数,只有一个操作码.这种模式的优缺点都很明显.优点是可以省略很多填充和间隔符号,缺点也显而易见,虚拟机在处理一些超过一个字节的数据的时候,不得不在运行时从字节中重建出具体数据的结构
```Java
do {
    自动计算PC寄存器的值加1
    根据PC寄存器的指示位置,从字节码流中取出操作码;
    if (字节码存在操作数) 从字节码流中取出操作数;
    执行操作码所定义的操作
} while (字节码流长度 > 0);
```
- 加载和存储指令
- 运算指令
- 类型转换指令对象创建与访问指令
- 操作数栈管理指令
- 控制转移指令
- 方法调用和返回指令
- 异常处理指令
- 同步指令
  
## 虚拟机类加载机制
### 总述
在Class文件中描述的各种信息,最终都需要加载到虚拟机中才能运行和使用.虚拟机把描述类的数据从Class文件加载到内存,并对数据进行校验,转换解析和初始化.最终形成可以被虚拟机直接使用的Java类型,这就是虚拟机的类加载机制.
- 在Java中,类型的加载,连接和初始化过程都是在程序运行期间完成的.此方法增加了性能开销但为Java应用程序提供了高度的灵活性.
- Java的动态扩展特性就是依赖运行期的动态加载和动态连接来实现的.
### 类的生命周期
类从被加载进虚拟内存中,到卸载出内存为止, 它的整个生命周期包括七个阶段:
- **加载(Loading)**
- **验证(Verification)**
- **准备(Preparation)**
- **解析(Resolution)**
- **初始化(Initialization)**
- **使用(Usage)**
- **卸载(Unloading)**

![类的生命周期](/media/posts/classlife.png)

其中验证,准备和解析三个部分统称为**连接(Linking)**.
**加载**,**验证**,**准备**,**初始化**和**卸载**这五个阶段的顺序是确定的. 类的加载过程必须按照这个顺序按部就班的*开始(这些阶段按部就班的开始但通常互相交叉混合式地进行.通常会在一个阶段执行的过程中调用,激活另一个阶段)*

解析阶段在某些情况下可以在初始化阶段之后再开始, 这是为了支持Java语言的运行时绑定.虚拟机规范并没有对加载进行严格的限制.在经过**加载**,**验证**,**准备**这三个阶段后,对于**初始化**阶段,虚拟机有严格的限制,*有且只有*五种情况必须立即对类进行初始化
- 遇到new, getstatic, putstatic, invokestatic这四条字节码指令时, 如果类没有进行过初始化,需要先触发其初始化. 常见的代码场景有,使用new实例化对象,读取或设置一个类的静态字段(被final修饰已在编译器把结果放入常量池的静态字段除外),还有调用一个类的静态方法的时候.
- 使用java.lang.reflect包的方法对类进行反射调用的时候
- 当初始化一个类的时候,如果发现其父类还没有进行过初始化,则需要先触发其父类的初始化.
- 当虚拟机启动的时候,用户需要指定一个要执行的主类(包含main()方法的那个类), 虚拟机会先初始化这个类.
- 当使用JDK1.7的动态语言支持时,如果一个java.lang.invoke.MethodHandle实例最后的解析结果是REF_getStatic, REF_putStatic,REF_invokeStatic的方法句柄,并且这个方法句柄所对应的类没有进行过初始化
除此之外的所有引用类的方式都不会触发初始化, 称为**被动引用**.下面进行简单的举例
```Java
public class SuperClass {
    static {
        system.out.println("SuperClass init");
    }

    public static int value = 123;
}

public class SubClass {
    static {
        System.out.println("SubClass init!");
    }
}

public class NotInitialization {
    public static void main(String[] args) {
        System.out.println(SubClass.value);
    }
}
/* 运行结果
* SuperClass init
* 123
*/
```
### 类加载的全过程
#### 加载(Loading)
"加载"是类加载的一个阶段.在这个阶段虚拟机需要完成三件事
+ 通过一个类的全限定名来获取定义此类的二进制字节流
+ 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
+ 在内存中生成一个代表这个类的java.lang.Class对象,作为方法区这个类的各种数据的访问入口.

虚拟机规范的这三点要求并不具体.从ZIP包中读取类的二进制字节流的方法演变成了JAR格式. 从网络中获取演变成了Applet.运行时计算生成演变出了动态代理技术.

对于非数组类数据来说, 可以由系统提供的引导类加载器来完成, 也可以由用户自定义的类加载器去完成, 开发人员可以通过定义自己的类加载器去控制字节流的获取方式(重写一个类加载器的loadClass()方法).

对于数组类而言, 由于数据类本身不通过类加载器创建,它是由Java虚拟机直接创建.但数组类的元素类型(Element Type)最终要靠类加载器去创建
- 如果组件类型(Component Type, 指数组去掉一个维度的类型)是引用类型, 则递归地采用之前提到的家在过程去加载这个组件类型
- 如果组件类型不是引用类型(如int[]),Java虚拟机将会把数组C标记为与引导类加载器关联.
- 数组类的可见性与它的组件类型的可见性一致, 如果组件类型不是引用类型,那数组类的可见性默认为public.

在类加载完成之后,虚拟机外的二进制字节流就按照虚拟机所需的格式存储在方法区之中. 内存中实例化一个java.lang.Class类的对象, 这个对象将作为程序访问方法区中的这些类型数据的外部接口.

实际上加载阶段和连接阶段的部分内容(如字节码文件格式验证)是交叉进行的.

#### 验证(Verification)
验证是**连接**阶段的第一步,这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求.并且不会危害虚拟机自身的安全. 这个阶段是否严谨直接决定了Java虚拟机能否承受恶意代码的攻击. 验证阶段大致完成四个检验动作:
- **文件格式验证**: 字节流是否符合Class文件格式的规范, 并且能被当前版本的虚拟机处理. 这一检验动作的主要目的是保证输入的字节流能正确的解析并存储于方法区之内. 只有通过了此阶段的检验后, 字节流才会进入内存的方法区中进行存储. 所以后面的验证阶段都基于方法区的存储结构进行的,不会再直接操作字节流.
- **元数据验证**: 对字节码描述的信息进行语义分析,以保证其描述的信息符合Java语言规范的要求.
- **字节码验证**: 通过数据流和控制流的分析,确定程序语义是合法的,符合逻辑的.
- **符号引用验证**: 这个阶段验证发生在虚拟机将符号引用转化为直接引用的时候, 这个自动转化动作将在连接的第三个阶段---解析阶段中发生. 符号引用验证可以看做是对类自身以外(常量池中的各种符号引用)的信息进行匹配性校验.

验证阶段是重要但非必要的阶段(因为对运行期没有影响).如果代码已经被反复使用或验证过,可以使用-Xverify:none参数来关闭大部分的类验证措施,以缩短虚拟机类的加载时间.

#### 准备(Preparation)
准备阶段是正式为类变量分配内存并设置类变量初始值的阶段, 这些变量所使用的内存都将在方法区中进行分配.
  > 初始值: 初始值"通常情况下是数据类型的零值" 例如 public static int value = 123; 变量value在准备阶段过后的初始值是0而不是123. 因为这时尚未开始执行任何Java方法,把value赋值为123的putstatic指令是程序被编译后,存放于类构造器<client()>方法中.赋值动作在初始化阶段才会执行.
  还存在一些"特殊情况",如果类字段的字段属性中存在ConstantValue属性,那在准备阶段变量value就会被初始化为ConstantValue属性所指定的值.例如 public static final int value = 123;

这时候进行内存分配的仅包括类变量(被static修饰的变量), 而不包括实例变量,实例变量将会在对象实例化时随着对象一起分配在Java堆中.

#### 解析(Resolution)
解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程.
> **符号引用(Symbolic References)**: 符号引用以一组符号来描述所引用的目标. 符号可以是任何形式的字面量, 只要使用时能无歧义地定位到目标即可(引用的目标不一定已经加载到了内存中).

> **直接引用(Direct Reference)**: 直接引用可以是直接指向目标的指针, 相对偏移量或者是一个能间接定位到目标的句柄.

解析动作主要针对类或接口, 字段, 类方法, 接口方法, 方法类型, 方法句柄和调用点限定符7类符号引用进行.
- **类或接口的解析**
  假设当前代码所处的类为D,如果要把一个从未解析过的符号引用N解析为一个类或者接口C的直接引用.虚拟机需要完成以下三个步骤
  + 如果C不是一个数组类型,那虚拟机将会把代表N的全限定名传递给D的类加载器去加载C这个类. 在加载过程中由于元数组验证,字节码验证的需要,又可能触发其他相关类的加载动作.
  + 如果C是一个数据类型,并且数据的元素类型是对象.那将会按照第一点的规则加载数据元素类型,接着由虚拟机生成一个代表此数组维度和元素的数组对象.
  + 如果以上未出现异常, 那么C在虚拟机中实际上已经成为一个有效的类或者接口了,但在解析完成之前还要进行符号引用验证,确认D是否具备对C的访问权限,
- **字段解析**
  要解析一个未被解析的字段符号引用, 首先将会对字段表内的class_index项中索引的CONSTANT_Class_info符号引用进行解析.,也就是对字段所属的类或者接口的符号引用.解析完成后,这个字段所属的类或者接口用C表示,C需进行以下的后续搜索
  + 如果C本身就包含了简单名称和字段描述符都与目标相匹配的字段,则返回这个字段的直接引用,查找结束.
  + 否则, 如果在C中实现了接口,按照继承关系由下至上递归搜索其父类,如果在父类中包含了简单名称和字段描述符都与目标相匹配的字段,则返回这个字段的直接引用,查找结束
  + 否则, 如果在C不是java.lang.Object的话,将按照继承关系从下往上递归搜索其父类,如果在父类中包含了简单名称和字段描述符都与目标相匹配的字段,则返回这个字段的直接引用,查找结束.
  + 否则, 查找失败, 抛出java.lang.NoSuchFieldError异常.
  
  当父类与接口同时存在一个同名字段是编译器会提示"The field **** is ambiguous",并且拒绝编译.
- **类方法解析**
  第一步也字段解析一样,解析出所属类或接口的符号引用. 若解析成功,我们依然用C表示这个类,
  + 类方法和接口方法符号引用的常量类型定义分开的,如果在类方法表中发现 class_index中的索引是个接口,就直接抛出java.lang.IncompatibleClassChangeError异常
  + 在类C中查找是否包含了简单名称和字段描述符都与目标相匹配的方法,如果有则返回这个方法的直接引用,查找结束
  + 在类C的父类中递归查找是否包含了简单名称和字段描述符都与目标相匹配的方法,如果有则返回这个方法的直接引用,查找结束
  + 在类C实现的接口列表及他们的父接口之中递归查找是否包含了简单名称和字段描述符都与目标相匹配的方法,如果有则说明类C是个抽象类,抛出java.lang.AbstractMethodError异常
- **接口方法解析**
  第一步也字段解析一样,解析出所属类或接口的符号引用. 若解析成功,我们依然用C表示这个接口.
  + 与类方法解析不同,如果在接口方法表中发现class_index中的索引C是个类而不是接口,那就直接抛出java.lang.IncompatibleClassChangeError异常.
  + 在接口C中查找是否包含了简单名称和字段描述符都与目标相匹配的方法,如果有则返回这个方法的直接引用,查找结束
  + 在接口C的父类中递归查找是否包含了简单名称和字段描述符都与目标相匹配的方法,知道java.lang.Object类,如果有则返回这个方法的直接引用,查找结束
  + 否则则视为失败
#### 初始化(Initializaiton)
类初始化是类加载过程的最后一步, 前面的步骤除了在加载阶段用户应用程序可以通过自定义类加载器参与之外, 其余动作完全由虚拟机主导和控制. 初始化阶段才真正开始执行类中定义的Java程序代码.

在准备阶段,变量已经被赋予了系统要求的初始值, 在初始化阶段则通过程序制定的主观计划去初始化类变量和其他资源. 初始化阶段是执行类构造器<client>方法的过程.
  - <client\>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块(static{}块)中的语句合并产生的,编译器收集的顺序是由语句在源文件中出现的顺序所决定的,静态语句块中只能访问到定义在静态语句块之前的变量,*定义在它之后的变量,在前面的静态语句块可以赋值,但是不能访问*
  ```Java
  public class Test {
      static {
          i = 0;        //给变量赋值可以正常编译通过
          System.out.print(i);      //这句编译器会提示"非法向前引用"
      }
  }
  ```
  - <client\>()方法与类的构造函数(或者说实例构造器<init\>()方法)不同,它不需要显式地调用父类构造器,虚拟机会保证在子类的<client\>()方法执行之前,父类的<client\>()已经执行完毕.
  - 由于父类的<client\>方法先执行,也意味着父类中定义的静态语句块要优先于子类的变量赋值操作.
  - <client\>方法对于类或者接口来说并不是必需的,如果一个类中没有静态语句块,也没有对变量的赋值操作,那么编译器可以不为这个类生成<client\>()方法.
  - 虚拟机会保证一个类的<client\>()方法在多线程环境下被正确的加锁,同步.多个线程去初始化一个类的话,只会有一个线程去执行这个类的<client\>()方法,其他则被阻塞.

### 类加载器
虚拟机团队把类加载阶段中"*通过一类的全限定名来获取描述此类的二进制字节流*"这个动作放到了Java虚拟机外部实现, 以便让应用程序自己决定如何去获取所需要的类.实现这个动作的代码模块称为**类加载器**

对于任意一个类,都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性.
```Java
public class ClassLoaderTest {
    public static void main(String[] args) throws Exception {
        ClassLoader myLoader = new ClassLoader(){
            @Override
            public Class<?> loadClass(String name) throws ClassNotFoundException {
                try{
                    String fileName = name.substring(name.lastIndexOf(".")+1) + ".class";
                    InputStream is = getClass().getResourceAsStream(fileName);
                    if (is == null) {
                        return super.loadClass(name);
                    }
                    byte[] b = new byte[is.available()];
                    is.read(b);
                    return defineClass(name, b, 0, b.length)
                } catch (IOException e){
                    throw new ClassNotFoundException(name);
                }
            }
        };

        Object obj = myLoader.loadClass("org.fenixsoft.classloading.ClassLoaderTest").newInstance();
        System.out.println(obj.getClass());
        // class org.fenixsoft.classloading.ClassLoaderTest
        System.out.println(obj instanceof org.fenixsoft.classloading.ClassLoaderTest);
        // False
    }
}
```
#### 双亲委派模型
从Java虚拟机的角度讲,只存在两种不同的类加载器:一种是**启动类加载器(Bootstrap ClassLoader)**,这个类加载器使用C++实现,是虚拟机的一部分;另一种就是所有其他的类加载器,这些类加载器都是由Java实现,独立于虚拟机的外部,并且都继承自java.lang.ClassLoader.

从开发者角度看,类加载器可以划分得更细致一些,绝大部分Java程序都会用到以下三种系统提供的类加载器.
  + **启动类加载器(Bootstrap ClassLoader)**: 这个类加载器负责将存放在<JAVA_HOME>\lib目录中的,或者被-Xbootclasspath参数所指定的路径中的,并且是虚拟机识别的类库加载到虚拟机内存中.
  + **扩展类加载器(Extension ClassLoader)**: 这个类加载器负责加载<JAVA_HOME>\lib\ext目录中的或者被java.ext.dirs系统变量所指定的路径中的所有类库,开发者可以直接使用
  + **应用程序类加载器(Application ClassLoader)**:由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值,所以一般也称它为系统类加载器.它负责加载用户类路径(ClassPath)上所指定的类库,开发者可以直接使用这个类加载器,如果应用程序中没有自定义过自己的类加载器,这则是默认的类加载器.

![双亲委派模型](/media/posts/delemodel.png)

双亲委派模型要求除了顶层的启动类加载器外,其余的类加载器都应当有自己的父类加载器.这里类加载器之间的父子关系一般不会以继承(Inheritance)的关系来实现,而都使用组合(Composition)关系来复用父加载器的代码.

工作过程是: 如果一个类加载器收到了类加载的请求, 它首先不会自己去尝试加载这个类,而是把这个请求委派给父类加载器去完成,只有当父类加载器反馈自己无法完成这个加载请求时(它的搜索范围中没有找到所需要的类)时,子加载器才会尝试自己去加载.

双亲委派模型的优点是Java类随着它的类加载器一起具备了一种带有优先级的层次关系.它对于保证Java程序的稳定运作很重要.
```Java
```
## 虚拟机字节码执行引擎
## 类加载及执行子系统的案例与实战 

# Part 3(程序编译与代码优化)
## 早期(编译期)优化
## 晚期(运行期)优化

# Part 4(高效并发)
## Java内存模型与线程
## 线程安全与锁优化