---
title: "数据库重点知识归纳"
tags: ["java", "Netty", "source code analysis"]
date: 2019-7-15
draft: false
---

### Database Index

常见问题:

- 为什么要使用索引
- 什么样的信息能成为索引
- 索引的数据结构
- 密集索引和稀疏索引

#### 索引的数据结构

- 生成索引,建立二叉查找树进行二分查找
- 生成索引,建立B-Tree结构进行查找
  - B-Tree定义
    - 根节点至少包括两个孩子
    - 树中每个节点最多含有m个孩子(m>=2)
    - 除根节点和叶节点外,其他每个节点至少有ceil(m/2)个孩子
    - 所有叶子节点都位于同一层
    - 假设每个非终端节点中包含有n个关键字信息, 其中
      - Ki(i=1...n)为关键字, 且关键字按顺序升序排序Ki-1<Ki
      - 关键字的个数n必须满足: \[ceil(m/2)-1\]\<=n\<=m-1
      - 非叶子结点的指针: P\[1], P\[2], ..., P\[M]指向关键字大于K\[M-1]的子树,其他P\[i]指向关键字属于(K\[i-1], K\[i])的子树
- 生成索引,建立B+-Tree结构进行查找
  - 定义
    - 非叶子节点的子树指针与关键字个数相同
    - 非叶子节点的子树指针P\[i],指向关键字值(K\[i],K\[i+1])的子树
    - 非叶子节点仅用来索引,数据都保存在叶子节点中
    - 所有叶子节点均有一个链指针指向下一个叶子节点
  - 优点
    - B+树的磁盘读写代价更低
    - B+树的查询效率更加稳定
    - B+树更有利于对数据库的扫描
- Hash索引
  - 缺点
    - 仅仅能满足"=", "IN", 不能使用范围查询
    - 无法被用来避免数据的排序操作
    - 不能利用部分索引键查询
    - 不能避免表扫描
    - 遇到大量Hash值相等的情况后性能并不一定就会比B-Tree索引高

#### 密集索引和稀疏索引

- 密集索引: 文件中的每个搜索码值都对应一个索引值,就是叶子节点保存了整行, innodb只有一个
- 稀疏索引: 文件只为索引码的某些值建立索引项, 比如 innodb的其他索引只存了键位信息和主键, myisam的所有索引都是

以MySQL为例

- 在InnoDB中: 表 根据主键顺序以B+ 树索引的形式存放的, 这种存储方式的表称为**索引组织表**
  - 主键索引(聚簇索引): 叶子节点存的是整行数据是密集索引
  - 非主键索引(二级索引): 叶子节点内容是主键的值, 是稀疏索引
- 在MyISAM中,  主键索引和其他索引没有任何区别, 都是稀疏索引, 表数据存储在独立的地方, 表数据和索引的分开的, 索引用地址指向表数据.

![](media/posts/mysql.png)

##### 聚簇索引
聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。比如，InnoDB的聚簇索引使用B+Tree的数据结构存储索引和数据。
当表有聚簇索引时，它的数据行实际上存放在索引的叶子页(leaf page)中。因为无法同时把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引（不过，覆盖索引可以模拟多个聚簇索引的情况）。

- 术语“聚簇”表示数据行和相邻的键值紧凑地存储在一起。
- 聚簇索引的二级索引：叶子节点不会保存引用的行的物理位置，而是保存行的主键值。

对于聚簇索引的存储引擎，数据的物理存放顺序与索引顺序是一致的，即：只要索引是相邻的，那么对应的数据一定也是相邻地存放在磁盘上的，如果主键不是自增id，可以想象，它会干些什么，不断地调整数据的物理地址、分页，当然也有其他一些措施来减少这些操作，但却无法彻底避免。但，如果是自增的，那就简单了，它只需要一页一页地写，索引结构相对紧凑，磁盘碎片少，效率也高。

对于非聚簇索引的存储引擎，**表数据存储顺序与索引顺序无关**，叶结点包含索引字段值及指向数据页数据行的逻辑指针，其行数量与数据表行数据量一致。

#### 如何定位并优化慢查询SQL

##### 1. 根据慢日志定位慢查询SQL
```sql
show variables like '%quer%'
show status like '%slow_queries%'
```
##### 2. 使用explain等工具分析SQL
```sql
explain select name from person_info_large order by name desc
```
##### 3. 修改SQL或尽量让SQL走索引
```sql
alter table person_info_large add index idx_name(name)
```

#### 最左匹配原则
- 最左前缀匹配原则, 非常重要的原则, mysql会一直向右匹配知道遇到范围查询(>, <, between, like)就会停止匹配, 比如a=3 and b=4 and c>5 and d=6 如果建立(a,b,c,d)顺序的索引,d是用不到索引的, 如果建立(a,b,d,c)的索引则都可以用到, a,b,d的顺序可以任意调整.
- =和in可以乱序, 如果a=1 and b=2 and c=3 建立(a,b,c)索引可以任意顺序, MySQL的查询优化器会帮你优化成索引可以识别的形式.

#### 索引多的缺点
- 数据量小的表不需要建立索引, 建立会增加额外的索引开销
- 数据变更需要维护索引, 因此更多的索引意味着更多的维护成本
- 更多的索引意味着也需要更多的空间

### 锁
- 按锁的粒度划分, 可分为表级锁, 行级锁, 页级锁
- 按锁级别划分, 可分为共享锁, 排它锁
- 按加锁方式划分, 可分为自动锁, 显式锁
- 按操作划分, 可分为DML锁, DDL锁
- 按使用方式划分, 可分为乐观锁, 悲观锁

#### MyISAM 与 InnoDB关于锁方面的区别
- MyISAM默认用的是表级锁, 不支持行级锁
- InnoDB默认用的是行级锁,也支持表级锁


#### 数据库事务的四大特性
#### 事务隔离级别以及各级别下的并发访问问题
#### InnoDB可重复读隔离级别下如何避免幻读
#### RC, RR级别下的InnoDB的非阻塞读如何实现

### 语法
#### GROUP BY
- 满足 "SELECT子句中的列名必须为分组列或列函数
- 列函数对于group by子句定义的每个组各返回一个结果

#### HAVING
- 通常与GROUP BY子句一起使用
- WHERE过滤行, HAVING过滤组
- 出现在同一sql的顺序: WHERE>GROUP BY> HAVING