<!DOCTYPE html>
<html lang="en">
<head>

  <meta charset="utf-8" />

  
  <title>Notes for Advanced Database System(COMP90050)</title>

  
  
  <link href="//cdn.jsdelivr.net" rel="dns-prefetch">
  <link href="//cdnjs.cloudflare.com" rel="dns-prefetch">
  <link href="//at.alicdn.com" rel="dns-prefetch">
  <link href="//fonts.googleapis.com" rel="dns-prefetch">
  <link href="//fonts.gstatic.com" rel="dns-prefetch">
  <link href="///disqus.com" rel="dns-prefetch">
  <link href="//c.disquscdn.com" rel="dns-prefetch">
  
  <link href="//www.google-analytics.com" rel="dns-prefetch">
  

  

  
  <meta name="author" content="Yang Zhang">
  <meta name="description" content="Different types of Database System There are multiple database technologies related to database structure. - Simple file systems like Unix File System - Relational Database System(RDBS) - Object Oriented(oo) Database System - Deductive Database System(DDBS) - Key-Value pair based Database System - NoSQL
Different types of Database Architectures  Centralised Database System Client-Server Distributed Database System World Wide Web Grid Computing/Databases that lead to Cloud Computing/Data Centres P2P Databases  Basic Memory Knowledge Memory Hierarchy In single core circumstance, the CPU communication case is : In muliple cores circumstance, the CPU communication case is : In Inter i7 Block Diagram, the CPU interaction is: Transaction Processing  A transaction is collection of operations that need to be performed on the physical and abstract application state.">

  
  
    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@gohugoio">
    <meta name="twitter:title" content="Notes for Advanced Database System(COMP90050)">
    <meta name="twitter:description" content="Different types of Database System There are multiple database technologies related to database structure. - Simple file systems like Unix File System - Relational Database System(RDBS) - Object Oriented(oo) Database System - Deductive Database System(DDBS) - Key-Value pair based Database System - NoSQL
Different types of Database Architectures  Centralised Database System Client-Server Distributed Database System World Wide Web Grid Computing/Databases that lead to Cloud Computing/Data Centres P2P Databases  Basic Memory Knowledge Memory Hierarchy In single core circumstance, the CPU communication case is : In muliple cores circumstance, the CPU communication case is : In Inter i7 Block Diagram, the CPU interaction is: Transaction Processing  A transaction is collection of operations that need to be performed on the physical and abstract application state.">
    <meta name="twitter:image" content="/images/avatar.png">
  

  
  <meta property="og:type" content="article">
  <meta property="og:title" content="Notes for Advanced Database System(COMP90050)">
  <meta property="og:description" content="Different types of Database System There are multiple database technologies related to database structure. - Simple file systems like Unix File System - Relational Database System(RDBS) - Object Oriented(oo) Database System - Deductive Database System(DDBS) - Key-Value pair based Database System - NoSQL
Different types of Database Architectures  Centralised Database System Client-Server Distributed Database System World Wide Web Grid Computing/Databases that lead to Cloud Computing/Data Centres P2P Databases  Basic Memory Knowledge Memory Hierarchy In single core circumstance, the CPU communication case is : In muliple cores circumstance, the CPU communication case is : In Inter i7 Block Diagram, the CPU interaction is: Transaction Processing  A transaction is collection of operations that need to be performed on the physical and abstract application state.">
  <meta property="og:url" content="https://yangzhanghavefun.github.io/yzzhan/post/adb/">
  <meta property="og:image" content="/images/avatar.png">




<meta name="generator" content="Hugo 0.51">


<link rel="canonical" href="https://yangzhanghavefun.github.io/yzzhan/post/adb/">

<meta name="renderer" content="webkit">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="format-detection" content="telephone=no,email=no,adress=no">
<meta http-equiv="Cache-Control" content="no-transform">


<meta name="robots" content="index,follow">
<meta name="referrer" content="origin-when-cross-origin">
<meta name="google-site-verification" content="_moDmnnBNVLBN1rzNxyGUGdPHE20YgbmrtzLIbxaWFc">
<meta name="msvalidate.01" content="22596E34341DD1D17D6022C44647E587">





<meta name="theme-color" content="#02b875">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<meta name="apple-mobile-web-app-title" content="Yzzhan Tech Repo">
<meta name="msapplication-tooltip" content="Yzzhan Tech Repo">
<meta name='msapplication-navbutton-color' content="#02b875">
<meta name="msapplication-TileColor" content="#02b875">
<meta name="msapplication-TileImage" content="/icons/icon-144x144.png">
<link rel="icon" href="https://yangzhanghavefun.github.io/yzzhan/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://yangzhanghavefun.github.io/yzzhan/icons/icon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://yangzhanghavefun.github.io/yzzhan/icons/icon-32x32.png">
<link rel="icon" sizes="192x192" href="https://yangzhanghavefun.github.io/yzzhan/icons/icon-192x192.png">
<link rel="apple-touch-icon" href="https://yangzhanghavefun.github.io/yzzhan/icons/icon-152x152.png">
<link rel="manifest" href="https://yangzhanghavefun.github.io/yzzhan/manifest.json">


<link rel="preload" href="https://yangzhanghavefun.github.io/yzzhan/styles/main.min.css" as="style">

<link rel="preload" href="https://fonts.googleapis.com/css?family=Lobster" as="style">
<link rel="preload" href="https://yangzhanghavefun.github.io/yzzhan/images/avatar.png" as="image">
<link rel="preload" href="https://yangzhanghavefun.github.io/yzzhan/images/grey-prism.svg" as="image">


<style>
  body {
    background: rgb(244, 243, 241) url('/images/grey-prism.svg') repeat fixed;
  }
</style>
<link rel="stylesheet" href="https://yangzhanghavefun.github.io/yzzhan/styles/main.min.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lobster">



<script src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.2/dist/medium-zoom.min.js"></script>




<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/video.js@7.3.0/dist/video-js.min.css">



  
  
<!--[if lte IE 8]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/videojs-ie8@1.1.2/dist/videojs-ie8.min.js"></script>
<![endif]-->

<!--[if lte IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/eligrey-classlist-js-polyfill@1.2.20180112/classList.min.js"></script>
<![endif]-->


</head>
  <body>
    
    <div class="suspension">
      <a role="button" aria-label="Go to top" title="Go to top" class="to-top is-hide"><span class="icon icon-up" aria-hidden="true"></span></a>
      
        
        <a role="button" aria-label="Go to comments" title="Go to comments" class="to-comment" href="#disqus_thread"><span class="icon icon-comment" aria-hidden="true"></span></a>
        
      
    </div>
    
    
  <header class="site-header">
  <img class="avatar" src="https://yangzhanghavefun.github.io/yzzhan/images/avatar.png" alt="Avatar">
  
  <h2 class="title">Yzzhan Tech Repo</h2>
  
  <p class="subtitle">~ Keep Simple &amp; Stupid ~</p>
  <button class="menu-toggle" type="button" aria-label="Main Menu" aria-expanded="false" tab-index="0">
    <span class="icon icon-menu" aria-hidden="true"></span>
  </button>

  <nav class="site-menu collapsed">
    <h2 class="offscreen">Main Menu</h2>
    <ul class="menu-list">
      
      
      
      
        <li class="menu-item
          
          
           is-active">
          <a href="https://yangzhanghavefun.github.io/yzzhan/">Home</a>
        </li>
      
        <li class="menu-item
          
          
          ">
          <a href="https://yangzhanghavefun.github.io/yzzhan/categories/">Categories</a>
        </li>
      
        <li class="menu-item
          
          
          ">
          <a href="https://yangzhanghavefun.github.io/yzzhan/tags/">Tags</a>
        </li>
      
        <li class="menu-item
          
          
          ">
          <a href="https://yangzhanghavefun.github.io/yzzhan/links/">Links</a>
        </li>
      
        <li class="menu-item
          
          
          ">
          <a href="https://yangzhanghavefun.github.io/yzzhan/about/">About</a>
        </li>
      
    </ul>
  </nav>
  <nav class="social-menu collapsed">
    <h2 class="offscreen">Social Networks</h2>
    <ul class="social-list"><li class="social-item">
          <a href="mailto:yzzhan@student.unimelb.edu.au" title="Email" aria-label="Email">
            <span class="icon icon-email" aria-hidden="true"></span>
          </a>
        </li><li class="social-item">
          <a href="//github.com/YangZhangHaveFun" title="GitHub" aria-label="GitHub">
            <span class="icon icon-github" aria-hidden="true"></span>
          </a>
        </li><li class="social-item">
          <a href="//weibo.com/%e5%88%b9%e9%82%a3%e7%81%ac%e8%a1%8c%e5%b9%b4" title="Weibo" aria-label="Weibo">
            <span class="icon icon-weibo" aria-hidden="true"></span>
          </a>
        </li><li class="social-item">
          <a href="https://yangzhanghavefun.github.io/yzzhan/images/qrcode.jpg" title="Wechat" aria-label="Wechat">
            <span class="icon icon-wechat" aria-hidden="true"></span>
          </a>
        </li></ul>
  </nav>
</header>

  <section class="main post-detail">
    <header class="post-header">
      <h1 class="post-title">Notes for Advanced Database System(COMP90050)</h1>
      <p class="post-meta">@Yang Zhang · Apr 17, 2019 · 24 min read</p>
    </header>
    <article class="post-content">

<h4 id="different-types-of-database-system">Different types of Database System</h4>

<p>There are multiple database technologies related to database structure.
- Simple file systems like Unix File System
- Relational Database System(RDBS)
- Object Oriented(oo) Database System
- Deductive Database System(DDBS)
- Key-Value pair based Database System
- NoSQL</p>

<h4 id="different-types-of-database-architectures">Different types of Database Architectures</h4>

<ul>
<li>Centralised Database System</li>
<li>Client-Server</li>
<li>Distributed Database System</li>
<li>World Wide Web</li>
<li>Grid Computing/Databases that lead to Cloud Computing/Data Centres</li>
<li>P2P Databases</li>
</ul>

<h3 id="basic-memory-knowledge">Basic Memory Knowledge</h3>

<h4 id="memory-hierarchy">Memory Hierarchy</h4>

<p>In single core circumstance, the CPU communication case is :
<img src="https://yangzhanghavefun.github.io/yzzhan/media/posts/cache.png" alt="Sinle core" />
In muliple cores circumstance, the CPU communication case is :
<img src="https://yangzhanghavefun.github.io/yzzhan/media/posts/multiCores.png" alt="Multi cores" />
In Inter i7 Block Diagram, the CPU interaction is:
<img src="https://yangzhanghavefun.github.io/yzzhan/media/posts/i7Cores.png" alt="I7 cores" /></p>

<h4 id="transaction-processing">Transaction Processing</h4>

<blockquote>
<p>A transaction is collection of operations that need to be performed on the physical and abstract application state.</p>
</blockquote>

<p>Structure of a transaction should be:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql">begin_Transaction()
        <span style="color:#f92672">&lt;</span>Sequence <span style="color:#66d9ef">of</span> operations <span style="color:#66d9ef">to</span> be performed<span style="color:#f92672">&gt;</span>
    <span style="color:#66d9ef">if</span> (successful)
        commit_Trans() <span style="color:#f92672">%</span> <span style="color:#66d9ef">Any</span> changes made durable.
    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">rollback</span>() <span style="color:#f92672">%</span><span style="color:#66d9ef">Any</span> changes made <span style="color:#66d9ef">are</span> <span style="color:#66d9ef">all</span> undone
end_Transaction()</code></pre></div>
<p><strong>Transaction processing</strong> contributed many concepts in distributed computing and fault tolerant computing.</p>

<h5 id="acid-atomicity-consistency-isolation-durability">ACID(atomicity, consistency, isolation, durability)</h5>

<dl>
<dt><strong>Atomicity</strong></dt>
<dd>A transaction’s changes to the state (Database) are atomic implying either all actions happen or none happen.</dd>
<dt><strong>Consistency</strong></dt>
<dd>A the transaction is a correct transformation of the state. Actions taken as a whole do not violate the integrity of the application state assuming transactions are correct programs.</dd>
<dt><strong>Isolation</strong></dt>
<dd>Even when several transactions are executed simultaneously, it appears to each transaction T that others executed either happen before T or after T but not at the same time.</dd>
<dt><strong>Durability</strong></dt>
<dd>State changes committed by a transaction survive failures.</dd>
</dl>

<h5 id="distributed-transaction-processing-system">distributed transaction processing system</h5>

<p>As for the distributed transaction processing system, it should look like this.
<img src="https://yangzhanghavefun.github.io/yzzhan/media/posts/dtbs.png" alt="distributed transaction processing system" /></p>

<p>The features of distributed transaction processing system.
- Application development features
- Repository features
- Database features</p>

<h4 id="probability-and-fault-tolerance">Probability and Fault Tolerance</h4>

<h5 id="concepts">Concepts</h5>

<ul>
<li>P(A) is the probability of an event A is happening in <strong>certain period</strong></li>
<li>Assuming event A and B is independent,

<ul>
<li>P(A and B) = P(A) * P(B)</li>
<li>P(A or B) = P(A) + P(B) - P(A) * P(B) = P(A) + P(B)</li>
</ul></li>
<li><strong>Mean time</strong> to the event A is 1/P(A). MT(A) = 1/P(A)</li>
<li><strong>Meantime to failure(MTTF)</strong> means the time I need to wait to see the failure(which means running period).</li>
<li><strong>Meantime to repair(MTTR)</strong> means the time I need to wait to see the repair finished.</li>
<li><strong>Module Availability</strong> measures the ratio of service accomplishment to elapsed time.
MA = MTTF/(MTTF + MTTR)</li>
</ul>

<h5 id="fault-tolerance-in-multiple-events-case">Fault tolerance in multiple events case</h5>

<p>If all <strong>N</strong> different events have same mean time <strong>M</strong>. The mean time to the first one of the evenets = M/N. It means that the more devices we use, the shorter time the system meets the failure.</p>

<h5 id="fault-types">Fault types</h5>

<h5 id="fault-tolerance">Fault Tolerance</h5>

<ul>
<li>Failvote - use two are more modules and compare their outputs. Stops if there are no majority outputs agreeing. It fails twice as often with duplication but gives clean failure semantics</li>
<li>Failfast - this scheme is similar to fail voting except the system senses which modules are available and then uses the majority of the available modules. (which means we only concern of majority among the working ones.)
&gt; In systems design, a fail-fast system is one which immediately reports at its interface any condition that is likely to indicate a failure. Fail-fast systems are usually designed to stop normal operation rather than attempt to continue a possibly flawed process. Such designs often check the system&rsquo;s state at several points in an operation, so any failures can be detected early. The responsibility of a fail-fast module is detecting errors, then letting the next-highest level of the system handle them.</li>
</ul>

<p>A 10-plex module system continues to operate until the failure of 9 modules in Failfast.
A 10-plex module system continues to operate until the failure of 5 modules in Failvote.</p>

<h4 id="how-to-improve-hardware-reliability">How to improve hardware reliability</h4>

<h4 id="how-to-improve-software-reliability">How to improve software reliability</h4>

<h5 id="process-pairing">Process-pairing</h5>

<h5 id="transaction-based-recovery">Transaction based recovery</h5>

<h4 id="how-to-improve-communication-system-reliability">How to improve communication system reliability</h4>

<h3 id="lock-mechanisms">Lock Mechanisms</h3>

<h4 id="pessimistic-concurrency-control">Pessimistic Concurrency Control</h4>

<h4 id="optimistic-concurrency-control">Optimistic Concurrency Control</h4>

<h4 id="two-phase-locking-2pl">Two Phase Locking(2PL)</h4>

<h4 id="priority-ceiling-protocol">Priority Ceiling Protocol</h4>

<h4 id="read-write-priority-ceiling">Read-Write Priority Ceiling</h4>

<p>We evaluate experimentally two sharing method- ologies, based on their original prototype systems, that exploit work sharing opportunities among concurrent queries at run-time:
<strong>Si- multaneous Pipelining (SP)</strong>
<strong>Global Query Plans (GQP)</strong>
These two methods build and evaluate a single query plan with shared operators. We show that SP and GQP are orthogonal techniques.</p>

<p>并发控制(Concurrency Control)就是保证并发执行的事务在某一隔离级别正确执行的机制. 并发控制由数据库的调度器负责,事务本身并不感知.</p>

<p>在这个过程中,对可能破坏数据正确性的冲突事务,调度器可以选择两种处理模式:
- Delay: 延迟某个事务的执行知道合法的时刻
- Abort: 直接放弃事务的提交,并回滚该事务可能造成的影响.</p>

<p>锁用来在并发下控制多个操作的顺序执行,以此来保证数据安全的变动.乐观锁(Optimistic Concurrency Control)和悲观锁(Pessimistic Concurrency Control)是基于数据库层面的.</p>

<h4 id="悲观锁-pessimistic-concurrency-control">悲观锁(Pessimistic Concurrency Control)</h4>

<p>悲观锁的基本理论是被悲观锁保护的数据是极其不安全的,任何不顺序执行的操作都会使其数据发生错误.
&gt; 我们经常使用的数据库是Mysql, mysql最常用的引擎是Innodb,Innodb默认使用的是行锁.而行锁是基于索引的,因此要想加上行锁,在加锁时必须命中索引,否则将使用表锁.</p>

<h4 id="乐观锁-optimistic-concurrency-control">乐观锁(Optimistic Concurrency Control)</h4>

<p>乐观锁的基本理论是受乐观锁保护的数据变动不会太频繁,因此可以允许多个事务同时对数据进行变动.但是乐观不代表不负责,当多个事务执行发生冲突时,只会有一个事务执行成功,剩下的进行补充操作,例如回滚(rollback).</p>

<h5 id="多版本-multiversion-mvcc">多版本(Multiversion MVCC)</h5>

<p>多版本的优势在于,可以让读写事务与只读事务互不干扰,因而获得更好的并行度,为了实现多版本的并发控制,需要给每个事务在开始时分配一个唯一标识TID,并对数据库对象增加以下信息:
- txd-id, 创建该版本的事务TID
- begin-ts及end-ts分别记录该版本创建和过期时的事务TID
- poiter 指向该对象的其他版本的链表.</p>

<p>基本思路是,每次对数据库对象的写操作都生成一个新的版本,用自己的TID标记新版本begin-ts以及上个版本的end-ts,并将自己加入链表.读操作对比自己的TID与数据版本的begin-ts,end-ts,找到其可见的最新的版本进行访问.
- Two-phase Locking(MV2PL)
- Timestamp Ordering(MVTO)
- Optimistic Concurrency Control(MVOCC)</p>

<p>无论何种并发控制的机制,归根结底都是在确定的隔离级别上尽可能的提高系统吞吐,可以说<strong>隔离级别</strong>选择决定了吞吐上限,而并发控制实现决定吞吐下限.</p>

<p>However, a transaction is serializable if we can guarantee that it would see exactly the same data if all its reads were repeated at the end of the transaction.</p>

<p>To ensure that a transaction T is serializable we must guarantee that the following two properties hold:
- <strong>Read stability</strong>:  If T reads some version V1 of a record during its processing, we must guarantee that V1 is still the version visible to T as of the end of the transaction, that is, V1 has not been replaced by another committed version V2. This can be implemented either by read locking V1 to prevent updates or by validating that V1 has not been updated before commit. This ensures that nothing has disappeared from the view.
- <strong>Phantom avoidance</strong>: We must also guarantee that the transaction’s scans would not return additional new versions. This can be implemented in two ways: by locking the scanned part of an index/table or by rescanning to check for new versions before commit. This ensures that nothing has been added to the view.</p>

<h4 id="to-meet-the-different-level-of-isolation-by-multi-version">To meet the different level of isolation by multi-version.</h4>

<ul>
<li>read uncommitted</li>
<li>read committed</li>
<li>repeatable read</li>
<li>serializable</li>
</ul>

<p>A transaction can be in one of four states: Active, Preparing, Committed, or Aborted.
<img src="https://yangzhanghavefun.github.io/yzzhan/media/posts/trastate.png" alt="Four States of transaction" /></p>

<p>write-write conflict. We follow the first-writer-wins rule and force transaction T to abort.</p>

<p>A serializable optimistic transaction keeps track of its reads, scans and writes. To this end, a transaction object contains three sets:
- ReadSet: contains pointers to every version read;
- ScanSet: stores information needed to repeat every scan;
- WriteSet: contains pointers to versions updated (old and new), versions deleted (old) and versions inserted (new).</p>

<p>Processing a read: a transaction reads only a committed version (created by a committed transaction). If the transaction which is processing a version is active, then the reader transaction waits until the creator transaction has committed or aborted. If the creator is aborted then the read request is scheduled for another version. Thus a read operation may be delayed but is never rejected and can be described as follows:
- find the version with largest write TS &lt; the requesting transaction’s TS;</p>

<pre><code>if transaction which created this version has committed then
  begin
    grant read; create new read TS for the version
  end
else block the read until the creator transaction of this version has committed or aborted;
</code></pre>

<p>Internally, data consistency is maintained by using a multiversion model (Multiversion Concurrency Control, MVCC). This means that each SQL statement sees a snapshot of data (a database version) as it was some time ago, regardless of the current state of the underlying data.</p>

<p>This prevents statements from viewing inconsistent data produced by concurrent transactions performing updates on the same data rows, providing transaction isolation for each database session.</p>

<p>MVCC, by eschewing the locking methodologies of traditional database systems, minimizes lock contention in order to allow for reasonable performance in multiuser environments.</p>

<p>The main advantage of using the MVCC model of concurrency control rather than locking is that in MVCC locks acquired for querying (reading) data do not conflict with locks acquired for writing data, and so reading never blocks writing and writing never blocks reading. PostgreSQL maintains this guarantee even when providing the strictest level of transaction isolation through the use of an innovative Serializable Snapshot Isolation (SSI) level.</p>

<p>Serializable level isolation indicates that any concurrent execution of a set of Serializable transactions is guaranteed to produce the same effect as running them one at a time in some order.</p>

<p><strong>dirty read</strong>: A transaction reads data written by a concurrent uncommitted transaction.</p>

<p><strong>nonrepeatable read</strong>: A transaction re-reads data it has previously read and finds that data has been modified by another transaction (that committed since the initial read).</p>

<p><strong>phantom read</strong>: A transaction re-executes a query returning a set of rows that satisfy a search condition and finds that the set of rows satisfying the condition has changed due to another recently-committed transaction.</p>

<p><strong>serialization anomaly</strong>:
The result of successfully committing a group of transactions is inconsistent with all possible orderings of running those transactions one at a time.</p>

<table>
<thead>
<tr>
<th>Isolation level</th>
<th>Dirty Read</th>
<th>Nonrepeatable Read</th>
<th>Phantom Read</th>
<th>Serialization Anomaly</th>
</tr>
</thead>

<tbody>
<tr>
<td>Read uncommitted</td>
<td>Allowed, but not in PG</td>
<td>Possible</td>
<td>Possible</td>
<td>Possible</td>
</tr>

<tr>
<td>Read committed</td>
<td>Not possible</td>
<td>Possible</td>
<td>Possible</td>
<td>Possible</td>
</tr>

<tr>
<td>Repeatable read</td>
<td>Not possible</td>
<td>Not possible</td>
<td>Allowed, but not in PG</td>
<td>Possible</td>
</tr>

<tr>
<td>Serializable</td>
<td>Not possible</td>
<td>Not possible</td>
<td>Not possible</td>
<td>Not possible</td>
</tr>
</tbody>
</table>

<h4 id="read-committed">Read Committed</h4>

<p>Read Committed is the default isolation level in PostgreSQL. When a transaction uses this isolation level, a SELECT query (without a FOR UPDATE/SHARE clause) sees only data committed <strong>before the query began</strong>. It never sees
- uncommitted data
- changes committed during query execution by concurrent transactions</p>

<p>The effect is that a <code>SELECT</code> query sees a snapshot of the database as of the instant the query begins to run.</p>

<p>However, <code>SELECT</code> does see the effects of previous updates executed within its own transaction, even though they are not yet committed. Also note that two successive <code>SELECT</code> commands can see different data, even though they are within a single transaction, if other transactions commit changes after the first <code>SELECT</code> starts and before the second <code>SELECT</code> starts.</p>

<p><code>UPDATE</code>, <code>DELETE</code>, <code>SELECT FOR UPDATE</code>, and <code>SELECT FOR SHARE</code> commands behave the same as <code>SELECT</code> in terms of searching for target rows: they will only find target rows that were committed as of the command start time.</p>

<p>However, such a target row might have already been updated (or deleted or locked) by another concurrent transaction by the time it is found. In this case, the would-be updater will wait for the first updating transaction to commit or roll back (if it is still in progress). If the first updater rolls back, then its effects are negated and the second updater can proceed with updating the originally found row.</p>

<p>If the first updater commits, the second updater will ignore the row if the first updater deleted it, otherwise it will attempt to apply its operation to the updated version of the row. The search condition of the command (the <code>WHERE</code> clause) is re-evaluated to see if the updated version of the row still matches the search condition. If so, the second updater proceeds with its operation using the updated version of the row.</p>

<p><code>INSERT with an ON CONFLICT DO UPDATE</code> clause behaves similarly.In Read Committed mode, each row proposed for insertion will either insert or update. Unless there are unrelated errors, one of those two outcomes is guaranteed. If a conflict originates in another transaction whose effects are not yet visible to the <code>INSERT</code> , the <code>UPDATE</code> clause will affect that row, even though possibly no version of that row is conventionally visible to the command.</p>

<p><code>INSERT with an ON CONFLICT DO NOTHING</code> clause may have insertion not proceed for a row due to the outcome of another transaction whose effects are not visible to the INSERT snapshot. Again, this is only the case in Read Committed mode.</p>

<p>Because of the above rules, it is possible for an updating command to see an inconsistent snapshot: it can see the effects of concurrent updating commands on the same rows it is trying to update, but it does not see effects of those commands on other rows in the database. This behavior makes Read Committed mode unsuitable for commands that involve complex search conditions.</p>

<p>The partial transaction isolation provided by Read Committed mode is adequate for many applications, and this mode is fast and simple to use; however, it is not sufficient for all cases. Applications that do complex queries and updates might require a more rigorously consistent view of the database than Read Committed mode provides.</p>

<h4 id="repeatable-read-isolation-level">Repeatable Read Isolation Level</h4>

<p>The Repeatable Read isolation level only sees data committed <strong>before the transaction began</strong>; it never sees either uncommitted data or changes committed during transaction execution by concurrent transactions. (However, the query does see the effects of previous updates executed within its own transaction, even though they are not yet committed.)</p>

<p>This is a stronger guarantee than is required by the SQL standard for this isolation level, and prevents all of the phenomena described in Table 13.1 except for serialization anomalies.</p>

<p>This level is different from Read Committed in that a query in a repeatable read transaction sees a snapshot as of the start of <strong>the first non-transaction-control statement</strong> in the transaction, not as of the start of the current statement within the transaction. Thus, successive SELECT commands within a single transaction see the same data, i.e., they do not see changes made by other transactions that committed after their own transaction started.</p>

<p>Applications using this level must be prepared to retry transactions due to serialization failures.</p>

<p><code>UPDATE</code>, <code>DELETE</code>, <code>SELECT FOR UPDATE</code>, and <code>SELECT FOR SHARE</code> commands behave the same as <code>SELECT</code> in terms of searching for target rows: they will only find target rows that were committed as of the transaction start time. However, such a target row might have already been updated (or deleted or locked) by another concurrent transaction by the time it is found. In this case, the repeatable read transaction will wait for the first updating transaction to commit or roll back (if it is still in progress). If the first updater rolls back, then its effects are negated and the repeatable read transaction can proceed with updating the originally found row. But if the first updater commits (and actually updated or deleted the row, not just locked it) then the repeatable read transaction will be rolled back with the message.</p>

<h4 id="serializable-isolation-level">Serializable Isolation Level</h4>

<p>The Serializable isolation level provides the strictest transaction isolation. This level emulates serial transaction execution for all committed transactions; as if transactions had been executed one after another, serially, rather than concurrently. However, like the Repeatable Read level, applications using this level must be prepared to retry transactions due to serialization failures.</p>

<p>In fact, this isolation level works exactly the same as Repeatable Read except that it monitors for conditions which could make execution of a concurrent set of serializable transactions behave in a manner inconsistent with all possible serial (one at a time) executions of those transactions.</p>

<p>When relying on Serializable transactions to prevent anomalies, it is important that any data read from a permanent user table not be considered valid until the transaction which read it has successfully committed. This is true even for read-only transactions.</p>

<p>To guarantee true serializability PostgreSQL uses predicate locking, which means that it keeps locks which allow it to determine when a write would have had an impact on the result of a previous read from a concurrent transaction, had it run first.</p>

<h3 id="explicit-locking">Explicit Locking</h3>

<h4 id="table-level-locks">Table-level Locks</h4>

<h4 id="row-level-locks">Row-level Locks</h4>

<h4 id="page-level-locks">Page-level Locks</h4>

<h3 id="concurrency-control-protocol">Concurrency Control Protocol</h3>

<h3 id="concurrency-control-approach">Concurrency Control Approach</h3>

<ul>
<li><strong>Two Phase Locking(2PL)</strong>: Determine serializability order of conflicting operations at runtime while txns executes</li>

<li><p><strong>Timestamp Ordering(T/O)</strong>: Determine serializability order of txns before they execute.</p>

<h4 id="two-phase-lock">Two-phase Lock</h4>

<p><strong>Two-phase lock</strong> is a standard solution and broad mathematical theory has been developed to analyse the problem.
&gt;Two-phase locking(2PL) is a concurrency control protocol that determines whethere a txn is allowed to access an object in the database on the fly.
&gt;The protocol does not need to know all of the queries that a txn will execute ahead of time.</p>

<h5 id="process">Process</h5></li>

<li><p><strong>Phase 1: Growing</strong></p>

<ul>
<li>Each txn requests the locks that it needs from the DBMS&rsquo;s lock manager.</li>
<li>The lock manager grants/denies lock requests.</li>
</ul></li>

<li><p><strong>Phase 2: Shrinking</strong></p>

<ul>
<li>The txn is allowed to only release the locks that it previously acquried. It can not acquire new locks.</li>
</ul></li>
</ul>

<p>The 2PL guarantees the conflict serialibility. However, there are two problems.
- There are potential schedules that are serializable but would not be allowed by 2PL. =&gt; Locking limits concurrency.
- May still have &ldquo;dirty read&rdquo;       <em>solutions</em> =&gt; Strict 2PL
- May lead to deadlocks         <em>solution</em> =&gt; Detection or Prevention</p>

<blockquote>
<p>A schedule is <strong>strict</strong> if a value written by a txn is not read or overwritten by other txns until it finishes.
The advantanges:
- Does not incur cascading aborts
- Aborted txns can be undone by just restoring original values of modified tuples</p>
</blockquote>

<p><strong>Deadlock Detection</strong>
The DBMS creates a waits-for graph to keep track of what locks each txn is waiting to acquire:
- Nodes are transactions
- Edge from $T_i$ to $T_j$ if $T_i$ is waiting for $T_j$ to release a lock.
The system will periodically check for cycles in waits-for graph and then make a decision on how to break it.</p>

<p><strong>Deadlock Handling</strong>
When the DBMS detecks a deadlock, it will select a &ldquo;victim&rdquo; txn to rollback to break the cycle. The victim txn will either restart or abort(common way) depending on how it was invoked.</p>

<p>There is a trade-off between the frequency of checking for deadlocks and how long txns have to wait before deadlocks are broken.</p>

<p><strong>Deadlock Handling&ndash;Victim Selection</strong>
Selecting the proper victim depends on a lot of different variables
- By age(lowest timestamp)
- By progress(least/most queries executed)
- By the # of items already locked
- By the # of txns that we have to rollback with it</p>

<p><strong>Deadlock Handling&ndash;Rollback Length</strong>
After selecting a victim txn to abort, the DBMS can also decide on how far to rollback the txn&rsquo;s changes
- Completely
- Minimally</p>

<p><strong>Deadlock Prevention</strong>
When a txn tries to acquire a lock that is held by another txn, the DBMS kills one of them to prevent a deadlock. This approach does not require a wait-for graph or detection algorithm.</p>

<p>Assign priorities based on timestamps: Older Timestamp = Higher Priority($T_1$ &gt; $T_2$)</p>

<ul>
<li>Wait-Die(&ldquo;Old Waits for Young&rdquo;): If requesting txn has higher priority than holding txn, then <em>requesting txn</em> wait else abort</li>
<li>Wound-Wait(&ldquo;Young Waits for Old&rdquo;): If requesting txn has higher priority than holding txn, then <em>holding txn</em> aborts and release lock else <em>requesting txn</em> wait.</li>
</ul>

<h5 id="lock-granularity">Lock Granularity</h5>

<p><strong>Intention Locks</strong>: allows a higher level node to be locked in shared or exclusive mode without having to check all descendent nodes. If a node is in an intention mode, then explicit locking is being done at a lower level in the tree.</p>

<ul>
<li>Intension-Shared(IS): Indicates explicit locking at a lower level with shared locks.</li>
<li>Intension-Exclusive(IX): Indicates locking at a lower level with exclusive or shared locks.</li>
<li>Shared+Intention-Exclusive(SIX): The subtree rooted by that node is locked explicitly in shared mode and explicit locking is being done at a lower level with exclusive-mode locks.</li>
</ul>

<p>To get S or IS lock on a node, the txn must hold at least IS on parent node.
To get X, IX or SIX on a node, must hold at least IX on parent node.</p>

<p>Intention locks help improve concurrency:
- Intention-Shared(IS):Intent to get S lock(s) at finer granularity.
- Intention-Exclusive(IX):Intent to get X lock(s) at finer granularity.
- Shared+Intention-Exclusive(SIX): Like S and IX at the same time.</p>

<h4 id="timestamp-ordering-t-o">Timestamp Ordering(T/O)</h4>

<p>Using timestamps to determine the serializability order of txns</p>

<p>if TS($T_i$)&lt;TS($T_j$),then the DBMS must ensure that the execution schedule is equivalent to a serial schedule where $T_i$ appears before $T_j$.</p>

<p>Each txn $T_i$ is assigned a unique fixed timestamp that is monotonically increasing.
- Let TS($T_i$) be the timestamp allocated to txn $T_i$.
- Different schemes assign timestamps at different times during the txn.</p>

<p>Implementation strategies could be System Clock, Logical Counter, Hybrid.</p>

<h5 id="basic-timestamp-ordering-protocol">Basic Timestamp Ordering Protocol</h5>

<p>Txns read and write objects without locks.</p>

<p>Every object X is tagged with timestamp of the last txn that successfully did read/write:
- W-TS(X): Write timestamp on X
- R-TS(X): Read timestamp on X</p>

<p><strong>READ PROCESS</strong>
<code>If TS($T_i$)&lt;W-TS(X)</code>, this violates timestamp order of $T_i$ with regard to the writer of X.
- Abort $T_i$ and restart it with same TS</p>

<p><code>Else</code>:
- Allow $T_i$ to read X.
- Update R-TS(X) to max(R-TS(X), TS($T_i$))
- Have to make a local copy of X to ensure repeatable reads for $T_i$</p>

<p><strong>WRITE PROCESS</strong>
<code>If TS($T_i$)&lt;W-TS(X) OR TS($T_i$)&lt;W-TS(X)</code>
- Abort and restart $T_i$</p>

<p><code>Else</code>:
- Allow $T_i$ to write X and update W-TS(X)
- Also have to make a local copy of X to ensure repeatable reads for $T_i$.</p>

<p><strong>THOMAS WRITE RULE</strong>
<code>If TS($T_i$)&lt;R-TS(X)</code>:
- Abort and restart $T_i$</p>

<p><code>If TS($T_i$)&lt;W-TS(X)</code>:
- Thomas Write Rule: Ignore the write and allow the txn to continue.
- This violates timestamp order of $T_i$</p>

<p><code>Else</code>:
- Allow $T_i$ to write X and update W-TS(X)</p>

<p><strong>Basic T/O-Performance Issue</strong>:
- High overhead from copying data to txn&rsquo;s workspace and from updating timestamps
- Long running txns can get starved.</p>

<h5 id="optimistic-concurrency-control-1">Optimistic Concurrency Control</h5>

<p>The DBMS creates a private workspace for each txn.
- Any object read is copied into workspace
- Modifications are applied to workspace.</p>

<p>When a txn commits, the DBMS compares workspace write set to see whether it conflicts with other txns.</p>

<p>If there are no conflicts, the write set is installed into the &ldquo;global&rdquo; database.
<strong>OCC Phases</strong></p>

<p><strong>Read Phase</strong>:Track the read/write sets of txns and store their writes in a private workspace.</p>

<p><strong>Validation Phase</strong>:When a txn commits, check whether it conflicts with other txns.</p>

<p><strong>Write Phase</strong>:If validation succeeds, apply private changes to database. Otherwise abort and restart the txn.</p>

<p><strong>Validation Phase</strong>:The DBMS needs to guarantee only serializable schedules are permitted.</p>

<p>$T_i$ checks other txns for RW and WW conflicts and makes sure that all conflicts go one way(from older txns to young txns). Record read set and write set while txns are running and write into private workspace.</p>

<p>Execute Validation and Write phase inside a protected critical section.</p>

<p>Each txn&rsquo;s timestamp is assigned at the beginning of the validation phase. Check the timestamp ordering of the committing txn with all other running txns.</p>

<p>If TS($T_i$) &lt; TS($T_j$), then one of the following three conditions must hold.
- $T_i$ completes all three phases before $T_j$ begins.
- $T_i$ completes before $T_j$ starts its Write phase, and $T_i$ does not write to any object read by $T_j$  $\implies$  WriteSet($T_i$) $\cap$ WriteSet($T_j$) = $\emptyset$
- $T_i$ completes its Read phase before $T_j$ completes its Read phase. And $T_i$ does not write to any object that is either read or written by $T_j$:
  - WriteSet($T_i$) $\cap$ ReadSet($T_j$) = $\emptyset$
  - WriteSet($T_i$) $\cap$ WriteSet($T_j$) = $\emptyset$</p>

<p>OCC works well when the # of conflicts is low:
- All txns are read-only(ideal)
- Txns access disjoint  subsets of data.</p>

<p>If the database is large and the workload is not skewed, then there is a low probability of conflict, so again locking is wasteful. Therefore, the performance issues could be concluded as :
- High overhead for copying data locally.
- Validation/Write phase bottlenecks.
- Aborts are more wasteful than in 2PL because they only occur after a txn has already executed.</p>

<h5 id="partition-based-timestamp-ordering">Partition-based Timestamp Ordering</h5>

<p>Txns are assigned timestamps based on when they arrive at the DBMS.</p>

<p>Partitions are protected by a single lock:
- Each txn is queued at the partitions it needs.
- The txn acquires a partition&rsquo;s lock if it has the lowest timestamp in that partition&rsquo;s queue.
- The txn starts when it has all of the locks for all the partitions that is will read/write.</p>

<p><strong>READ PROCESS</strong>
Txns can read anything that they want at the partitions that they have locked. If a txn tries to access a partition that it does not have the lock, it is aborted+restarted.
<strong>WRITE PROCESS</strong>
All updates occur in place.
- Maintain a separate in-memory buffer to undo changes if the txn aborts.</p>

<p>If a txn tries to write a partition that it does not have the lock, it is aborted+restarted.</p>

<p>The Partition-based T/O protocol is fast if:
- The DBMS knows waht partitions the txn needs before it starts.
- Most(if not all)txns only need to access a single partition.</p>

<p>However, Multi-partition txns causes partition to be idle while txn executes.</p>

<h2 id="multi-version-concurrency-control">Multi-version Concurrency Control</h2>

<p>The DBMS maintains multiple physical versions of a single logical object in the database:
- When a txn writes to an object, the DBMS creates a new version of that object.
- When a txn reads an objects, it reads the newest version that existed when the txn started.</p>

<p>The principles of MVCC are:
- Writers don&rsquo;t block readers.
- Readers don&rsquo;t block writers.</p>

<p>Read-only txns can read a <strong>consistent snapshot</strong> without acquiring locks and timestamps is used to determine the visibility. Meanwhile, MVCC easily support <strong>time-travel</strong> queries</p>

<p>MVCC is more than just a concurrency control protocol. It completely affects how the DBMS manages transactions and the database.</p>

<h3 id="mvcc-design-decisions">MVCC DESIGN DECISIONS</h3>

<ul>
<li>Concurrency Control Protocol</li>
<li>Version Storage</li>
<li>Garbage Collection</li>
<li>Index Management</li>
</ul>

<h4 id="concurrency-control-protocol-1">Concurrency Control Protocol</h4>

<ul>
<li>Timestamp Ordering $\implies$ Assign txns timestamps that determine serial order.</li>
<li>Optimistic Cocurrency Control $\implies$ Three-phase protocol and private workspace for new version</li>
<li>Two-Phase Locking $\implies$ Txns acquire appropriate lock on physical they can read/write a logical tuple.</li>
</ul>

<h4 id="version-storage">Version Storage</h4>

<p>The DBMS uses the tuples&rsquo; pointer filed to create a <strong>version chain</strong> per logical tuple.
- this allows the DBMS to find the version that is visible to a particular txn at runtime.
- Indexes always point to the &ldquo;head&rdquo; of the chain.</p>

<p>Different storage schemes determine where/what to store for each version. Here shows the approaches.</p>

<ul>
<li>Append-Only Storage: New versions are appended to the same table space.</li>
<li>Time-Travel Storage: Old versions are copied to separate table space.</li>
<li>Delta Storage: The original values of the modified attributes are copied into a separate delta record space.</li>
</ul>

<h4 id="garbage-collection">Garbage Collection</h4>

<p>The DBMS needs to remove reclaimable physical versions from the database over time.</p>

<ul>
<li>No active txn in the DBMS can &ldquo;see&rdquo; that version(SI)</li>
<li>The version was created by an aborted txn.</li>
</ul>

<p>Two additional design decision:</p>

<ul>
<li>How to look for expired versions</li>
<li>How to decide when it is safe to reclaim the memory</li>
</ul>

<p>These are two collection level.</p>

<ul>
<li>Tuple level</li>
<li>Transaction level</li>
</ul>

<p><strong>Tuple Level</strong>: find old versions by examining tuples directly. Background Vacuuming vs Cooperative Cleaning.</p>

<blockquote>
<p><strong>Background Vacuuming</strong>: Separate threads periodically scan the table and look for reclaimable versions. Works with any storage.</p>

<p><strong>Cooperative Cleaning</strong>: Worker threads identify reclaimable versions as they traverse version chain. Only works with O2N.</p>
</blockquote>

<p><strong>Transaction Level</strong>: Txns keep trak of their old versions so the DBMS does not have to scan tuples to determine visibility.</p>

<p>In transaction level GC, each txn keeps track of its read/write set. The DBMS determines when all versions created by a finished txn are no longer visible.</p>

<h4 id="index-management">Index Management</h4>

<p>Primary key indexes point to version chain head.
- How often the DBMS has to update the pkey index depends on whether the system creates new versions when a tuple is updated.
-  If a txn updates a tuple’s pkey attribute(s), then this is treated as an <code>DELETE</code> followed by an <code>INSERT</code>. Secondary indexes are more complicated&hellip;</p>

<p>For secondary Index, there are two approaches.
- Logical Pointers: Use a fixed identifier per tuple that does not change.
  - Requires an extra indirection layer.
  - Primary Key(MySQL) vs. Tuple Id
- Physical Pointers: Use the physical address to the version chain head.
<img src="https://yangzhanghavefun.github.io/yzzhan/media/posts/adbgc.png" alt="MVCC Implimentations" /></p>

<p>MVCC is the widely used scheme in DBMSs. Even systems that do not support multi-statement txns(NoSQL) to use it.</p>

<h4 id="concepts-history">Concepts &amp; History</h4>

<p>At first, we apply 2PL to ensure the consistency of concurrency. However, lock operation will extremely limit the performance and scalability in concurrent database or distributed databse. Therefore, the researchers camp up with the idea of version to get rid of most lock operations. The final aim of multi-version concurrency control is that readers don&rsquo;t block writers and writers don&rsquo;t block readers.</p>

<p>Protocol was first proposed in 1978 MIT PhD</p>

<p>First implementations was Rdb/VMS and InterBase at DEC in early 1980s.</p>

<p>The core solution to avoid lock is snapshot. Based on different</p>

<p>sed ri ’s/session required required pam_loginuid.so/g ’ / etc/pam .d/sshd pam_loginuid .so/#session</p>

<h2 id="another-explainantion">Another EXPLAINANTION</h2>

<p>Two-phase locking (2PL) synchronizes reads and writes by explicitly detecting and preventing conflicts between concurrent operations.</p>

<p>Before reading data item x, a transaction must &ldquo;own&rdquo; a readlock on x. Before writing into x, it must &ldquo;own&rdquo; a writelock on x. The ownership of locks is governed by two rules:
- different transactions cannot simultaneously own conflicting locks;
- once a transaction surrenders ownership of a lock, it may never obtain additional locks.</p>

<p>The definition of conflicting lock depends on the type of synchronization being performed:
- for rw synchronization two locks conflict:
  - both are locks on the same data item
  - one is a readlock and the other is a writelock
- for ww synchronization two locks conflict:
  -  both are locks on the same data item
  -  both are writelocks.</p>

<p>The second lock ownership rule causes every transaction to obtain locks in a two-phase manner. During the growing phase the transaction obtains locks without releasing any locks. By releasing a lock the transaction enters the <strong>shrinking phase</strong>.</p>

<p>During this phase the transaction releases locks, and, by rule 2, is prohibited from obtaining additional locks. When the transaction terminates (or aborts), all remaining locks are automatically released.</p>

<p>Two-phase locking is a correct synchronization technique, meaning that 2PL attains an acyclic <code>rwr</code> or <code>ww</code> relation when used for rw (ww) synchronization.</p>

<p>The serialization order attained by 2PL is determined by the order in which transactions obtain locks.</p>

<p>The point at the end of the growing phase, when a transaction owns all the locks it ever will own, is called the <strong>locked point</strong> of the transaction.</p>

<h5 id="basic-2pl-implementation">Basic 2PL Implementation</h5>

<p>A distributed database management system (DDBMS) is a collection of sites interconnected by a network. Each site is a computer running one or both of the following software modules: a transaction manager &trade; or a data manager (DM). TMs supervise interactions between users and the DDBMS while DMs manage the actual database.</p>
</article>
    <footer class="post-footer">
      
      <ul class="post-tags">
        
          <li><a href="https://yangzhanghavefun.github.io/yzzhan/tags/concurrency"><span class="tag">Concurrency</span></a></li>
        
          <li><a href="https://yangzhanghavefun.github.io/yzzhan/tags/database"><span class="tag">Database</span></a></li>
        
      </ul>
      
      <p class="post-copyright">
        © This post is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License，please give source if you wish to quote or reproduce.
      </p>
    </footer>
    
      <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "disqus_shortname" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
      
    
  </section>
  
<footer class="site-footer">
  <p>© 2017-2019 Yzzhan Tech Repo</p>
  <p>Powered by <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> with theme <a href="https://github.com/laozhu/hugo-nuo" target="_blank" rel="noopener">Nuo</a>.</p>
  
</footer>


<script src="https://cdn.jsdelivr.net/npm/smooth-scroll@15.0.0/dist/smooth-scroll.min.js"></script>



<script async src="https://cdn.jsdelivr.net/npm/video.js@7.3.0/dist/video.min.js"></script>




<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$','$'], ['\\(','\\)']],
      displayMath: [['$$','$$'], ['\\[','\\]']],
      processEscapes: true,
      processEnvironments: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
      TeX: { equationNumbers: { autoNumber: "AMS" },
      extensions: ["AMSmath.js", "AMSsymbols.js"] }
    },
  });
</script>
<script type="text/x-mathjax-config">
  // Fix <code> tags after MathJax finishes running. This is a
  // hack to overcome a shortcoming of Markdown. Discussion at
  // https://github.com/mojombo/jekyll/issues/199
  MathJax.Hub.Queue(() => {
    MathJax.Hub.getAllJax().map(v => v.SourceElement().parentNode.className += ' has-jax');
  });
</script>



<script src="https://yangzhanghavefun.github.io/yzzhan/scripts/index.min.js"></script>

<script>
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('\/service-worker.js').then(function() {
      console.log('[ServiceWorker] Registered');
    });
  }
</script>




<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-XXXXXXXX-X', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>







  </body>
</html>
