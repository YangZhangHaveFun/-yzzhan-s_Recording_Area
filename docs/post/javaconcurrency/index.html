<!DOCTYPE html>
<html lang="en">
<head>

  <meta charset="utf-8" />

  
  <title>深入理解java并发知识的归纳</title>

  
  
  <link href="//cdn.jsdelivr.net" rel="dns-prefetch">
  <link href="//cdnjs.cloudflare.com" rel="dns-prefetch">
  <link href="//at.alicdn.com" rel="dns-prefetch">
  <link href="//fonts.googleapis.com" rel="dns-prefetch">
  <link href="//fonts.gstatic.com" rel="dns-prefetch">
  <link href="///disqus.com" rel="dns-prefetch">
  <link href="//c.disquscdn.com" rel="dns-prefetch">
  
  <link href="//www.google-analytics.com" rel="dns-prefetch">
  

  

  
  <meta name="author" content="Yang Zhang">
  <meta name="description" content="多线程基础 多线程的三个问题  多核和缓存导致的可见性问题: 一个线程对共享变量的修改，另外一个线程能够立刻看到，我们称为可见性. 线程切换带来的原子性问题: 我们把一个或者多个操作在 CPU 执行的过程中不被中断的特性原子性. 编译优化带来的有序性问题: 代码按照预期的顺序执行,称为有序性  Java内存模型 Java 内存模型规范了 JVM 如何提供按需禁用缓存和编译优化的方法。具体来说，这些方法包括 volatile, synchronized和final关键字, 以及六项Happen-Before规则.
Volatile volatile 关键字最原始的意义是禁用CPU缓存.变量的读写必须从内存中读取或者写入.
class VolatileExample { int x = 0; volatile boolean v = false; public void writer() { x = 42; v = true; } public void reader() { if (v == true) { // 若有两个线程,一个线程进行writer()一个线程进行reader()则  // 这里 X 在1.5之前 是 0 或者42, X在1.5之后一定是42.  } } }  Happen-Before规则 Java1.">

  
  
    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@gohugoio">
    <meta name="twitter:title" content="深入理解java并发知识的归纳">
    <meta name="twitter:description" content="多线程基础 多线程的三个问题  多核和缓存导致的可见性问题: 一个线程对共享变量的修改，另外一个线程能够立刻看到，我们称为可见性. 线程切换带来的原子性问题: 我们把一个或者多个操作在 CPU 执行的过程中不被中断的特性原子性. 编译优化带来的有序性问题: 代码按照预期的顺序执行,称为有序性  Java内存模型 Java 内存模型规范了 JVM 如何提供按需禁用缓存和编译优化的方法。具体来说，这些方法包括 volatile, synchronized和final关键字, 以及六项Happen-Before规则.
Volatile volatile 关键字最原始的意义是禁用CPU缓存.变量的读写必须从内存中读取或者写入.
class VolatileExample { int x = 0; volatile boolean v = false; public void writer() { x = 42; v = true; } public void reader() { if (v == true) { // 若有两个线程,一个线程进行writer()一个线程进行reader()则  // 这里 X 在1.5之前 是 0 或者42, X在1.5之后一定是42.  } } }  Happen-Before规则 Java1.">
    <meta name="twitter:image" content="/images/avatar.png">
  

  
  <meta property="og:type" content="article">
  <meta property="og:title" content="深入理解java并发知识的归纳">
  <meta property="og:description" content="多线程基础 多线程的三个问题  多核和缓存导致的可见性问题: 一个线程对共享变量的修改，另外一个线程能够立刻看到，我们称为可见性. 线程切换带来的原子性问题: 我们把一个或者多个操作在 CPU 执行的过程中不被中断的特性原子性. 编译优化带来的有序性问题: 代码按照预期的顺序执行,称为有序性  Java内存模型 Java 内存模型规范了 JVM 如何提供按需禁用缓存和编译优化的方法。具体来说，这些方法包括 volatile, synchronized和final关键字, 以及六项Happen-Before规则.
Volatile volatile 关键字最原始的意义是禁用CPU缓存.变量的读写必须从内存中读取或者写入.
class VolatileExample { int x = 0; volatile boolean v = false; public void writer() { x = 42; v = true; } public void reader() { if (v == true) { // 若有两个线程,一个线程进行writer()一个线程进行reader()则  // 这里 X 在1.5之前 是 0 或者42, X在1.5之后一定是42.  } } }  Happen-Before规则 Java1.">
  <meta property="og:url" content="https://yangzhanghavefun.github.io/yzzhan/post/javaconcurrency/">
  <meta property="og:image" content="/images/avatar.png">




<meta name="generator" content="Hugo 0.51">


<link rel="canonical" href="https://yangzhanghavefun.github.io/yzzhan/post/javaconcurrency/">

<meta name="renderer" content="webkit">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="format-detection" content="telephone=no,email=no,adress=no">
<meta http-equiv="Cache-Control" content="no-transform">


<meta name="robots" content="index,follow">
<meta name="referrer" content="origin-when-cross-origin">
<meta name="google-site-verification" content="_moDmnnBNVLBN1rzNxyGUGdPHE20YgbmrtzLIbxaWFc">
<meta name="msvalidate.01" content="22596E34341DD1D17D6022C44647E587">





<meta name="theme-color" content="#02b875">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<meta name="apple-mobile-web-app-title" content="Yzzhan Tech Repo">
<meta name="msapplication-tooltip" content="Yzzhan Tech Repo">
<meta name='msapplication-navbutton-color' content="#02b875">
<meta name="msapplication-TileColor" content="#02b875">
<meta name="msapplication-TileImage" content="/icons/icon-144x144.png">
<link rel="icon" href="https://yangzhanghavefun.github.io/yzzhan/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://yangzhanghavefun.github.io/yzzhan/icons/icon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://yangzhanghavefun.github.io/yzzhan/icons/icon-32x32.png">
<link rel="icon" sizes="192x192" href="https://yangzhanghavefun.github.io/yzzhan/icons/icon-192x192.png">
<link rel="apple-touch-icon" href="https://yangzhanghavefun.github.io/yzzhan/icons/icon-152x152.png">
<link rel="manifest" href="https://yangzhanghavefun.github.io/yzzhan/manifest.json">


<link rel="preload" href="https://yangzhanghavefun.github.io/yzzhan/styles/main.min.css" as="style">

<link rel="preload" href="https://fonts.googleapis.com/css?family=Lobster" as="style">
<link rel="preload" href="https://yangzhanghavefun.github.io/yzzhan/images/avatar.png" as="image">
<link rel="preload" href="https://yangzhanghavefun.github.io/yzzhan/images/grey-prism.svg" as="image">


<style>
  body {
    background: rgb(244, 243, 241) url('/images/grey-prism.svg') repeat fixed;
  }
</style>
<link rel="stylesheet" href="https://yangzhanghavefun.github.io/yzzhan/styles/main.min.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lobster">



<script src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.2/dist/medium-zoom.min.js"></script>




<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/video.js@7.3.0/dist/video-js.min.css">



  
  
<!--[if lte IE 8]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/videojs-ie8@1.1.2/dist/videojs-ie8.min.js"></script>
<![endif]-->

<!--[if lte IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/eligrey-classlist-js-polyfill@1.2.20180112/classList.min.js"></script>
<![endif]-->


</head>
  <body>
    
    <div class="suspension">
      <a role="button" aria-label="Go to top" title="Go to top" class="to-top is-hide"><span class="icon icon-up" aria-hidden="true"></span></a>
      
        
        <a role="button" aria-label="Go to comments" title="Go to comments" class="to-comment" href="#disqus_thread"><span class="icon icon-comment" aria-hidden="true"></span></a>
        
      
    </div>
    
    
  <header class="site-header">
  <img class="avatar" src="https://yangzhanghavefun.github.io/yzzhan/images/avatar.png" alt="Avatar">
  
  <h2 class="title">Yzzhan Tech Repo</h2>
  
  <p class="subtitle">~ Keep Simple &amp; Stupid ~</p>
  <button class="menu-toggle" type="button" aria-label="Main Menu" aria-expanded="false" tab-index="0">
    <span class="icon icon-menu" aria-hidden="true"></span>
  </button>

  <nav class="site-menu collapsed">
    <h2 class="offscreen">Main Menu</h2>
    <ul class="menu-list">
      
      
      
      
        <li class="menu-item
          
          
           is-active">
          <a href="https://yangzhanghavefun.github.io/yzzhan/">Home</a>
        </li>
      
        <li class="menu-item
          
          
          ">
          <a href="https://yangzhanghavefun.github.io/yzzhan/categories/">Categories</a>
        </li>
      
        <li class="menu-item
          
          
          ">
          <a href="https://yangzhanghavefun.github.io/yzzhan/tags/">Tags</a>
        </li>
      
        <li class="menu-item
          
          
          ">
          <a href="https://yangzhanghavefun.github.io/yzzhan/links/">Links</a>
        </li>
      
        <li class="menu-item
          
          
          ">
          <a href="https://yangzhanghavefun.github.io/yzzhan/about/">About</a>
        </li>
      
    </ul>
  </nav>
  <nav class="social-menu collapsed">
    <h2 class="offscreen">Social Networks</h2>
    <ul class="social-list"><li class="social-item">
          <a href="mailto:yzzhan@student.unimelb.edu.au" title="Email" aria-label="Email">
            <span class="icon icon-email" aria-hidden="true"></span>
          </a>
        </li><li class="social-item">
          <a href="//github.com/YangZhangHaveFun" title="GitHub" aria-label="GitHub">
            <span class="icon icon-github" aria-hidden="true"></span>
          </a>
        </li><li class="social-item">
          <a href="//weibo.com/%e5%88%b9%e9%82%a3%e7%81%ac%e8%a1%8c%e5%b9%b4" title="Weibo" aria-label="Weibo">
            <span class="icon icon-weibo" aria-hidden="true"></span>
          </a>
        </li><li class="social-item">
          <a href="https://yangzhanghavefun.github.io/yzzhan/images/qrcode.jpg" title="Wechat" aria-label="Wechat">
            <span class="icon icon-wechat" aria-hidden="true"></span>
          </a>
        </li></ul>
  </nav>
</header>

  <section class="main post-detail">
    <header class="post-header">
      <h1 class="post-title">深入理解java并发知识的归纳</h1>
      <p class="post-meta">@Yang Zhang · May 13, 2019 · 3 min read</p>
    </header>
    <article class="post-content">

<h3 id="多线程基础">多线程基础</h3>

<h4 id="多线程的三个问题">多线程的三个问题</h4>

<ul>
<li>多核和缓存导致的可见性问题: 一个线程对共享变量的修改，另外一个线程能够立刻看到，我们称为<strong>可见性</strong>.</li>
<li>线程切换带来的原子性问题: 我们把一个或者多个操作在 CPU 执行的过程中不被中断的特性<strong>原子性</strong>.</li>
<li>编译优化带来的有序性问题: 代码按照预期的顺序执行,称为<strong>有序性</strong></li>
</ul>

<h4 id="java内存模型">Java内存模型</h4>

<p>Java 内存模型规范了 JVM 如何提供按需禁用缓存和编译优化的方法。具体来说，这些方法包括 <strong>volatile</strong>, <strong>synchronized</strong>和<strong>final</strong>关键字, 以及六项<strong>Happen-Before</strong>规则.</p>

<h5 id="volatile">Volatile</h5>

<p>volatile 关键字最原始的意义是禁用CPU缓存.变量的读写必须从内存中读取或者写入.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">VolatileExample</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">volatile</span> <span style="color:#66d9ef">boolean</span> v <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">writer</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        x <span style="color:#f92672">=</span> 42<span style="color:#f92672">;</span>
        v <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">reader</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>v <span style="color:#f92672">==</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#75715e">// 若有两个线程,一个线程进行writer()一个线程进行reader()则
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// 这里 X 在1.5之前 是 0 或者42, X在1.5之后一定是42.
</span><span style="color:#75715e"></span>        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span> </code></pre></div>
<h5 id="happen-before规则">Happen-Before规则</h5>

<p>Java1.5 用<strong>Happen-Before</strong>规则来解决这个问题. 下面介绍六项<strong>Happen-Before</strong>的规则. 首先<strong>Happen-Before</strong>表示前面一个操作的结果对后续操作是可见的.
- <strong>程序的顺序性规则</strong>: 这条规则是指在一个线程中, 按照程序顺序, 前面的操作Happens-Before于后续的任意操作.
- <strong>Volatile规则</strong>: 这条规则是指对一个volatile的写操作, Happens-Before于后续对这个volatile变量的读操作.
- <strong>传递性规则</strong>: 这条规则指如果A Happens-Before B, 且 B Happens-Before C, 那么A Happens-Before C.
- <strong>管程中的锁规则</strong>: 这条规则指一个对锁的解锁 Happens-Before 于后续对这个锁的枷锁.
- <strong>线程的start的规则</strong>: 这条规则指主线程启动子线程B后,子线程能够看到主线程在启动子线程B前的操作.
    <code>java
    Thread sub = new Thread(()-&gt;{
        // 主线程调用B.start() 之前
        //所有对共享变量的修改,此处皆可见
        //这里var == 77 ---&gt; return true
    });
    int var = 77;
    sub.start()
</code>
- <strong>线程的join的规则</strong>: 这条规则指主线程A等待子线程B完成(主线程A通过调用子线程B的join()方法实现), 当子线程B完成后(主线程A中join()方法返回), 主线程能够&rdquo;看到&rdquo;子线程的操作. 能够看到的部分是指对<strong>共享变量</strong>的修改.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    Thread sub <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Thread<span style="color:#f92672">(()-&gt;{</span>
        var <span style="color:#f92672">=</span> 66
    <span style="color:#f92672">});</span>
    <span style="color:#66d9ef">int</span> var <span style="color:#f92672">=</span> 77<span style="color:#f92672">;</span>
    sub<span style="color:#f92672">.</span><span style="color:#a6e22e">start</span><span style="color:#f92672">()</span>
    sub<span style="color:#f92672">.</span><span style="color:#a6e22e">join</span><span style="color:#f92672">()</span>
    <span style="color:#75715e">//此时var的数值变为了66
</span><span style="color:#75715e"></span>    <span style="color:#960050;background-color:#1e0010">```</span>

Java内存模型关于JVM的部分见深入理解JVM的读书总结<span style="color:#f92672">.</span>

<span style="color:#960050;background-color:#1e0010">####</span> 如果解决并发原子性问题<span style="color:#f92672">---</span>互斥锁
我们称 <span style="color:#f92672">**</span>同一时刻只有一个线程执行<span style="color:#f92672">**</span>这个条件为<span style="color:#f92672">**</span>互斥<span style="color:#f92672">(</span>mutex<span style="color:#f92672">)**.</span> 一段需要互斥执行的代码称为<span style="color:#f92672">**</span>临界区<span style="color:#f92672">(</span>critical area<span style="color:#f92672">)**,</span> 需要注意的是我们需要标注出来临界区内受保护的资源<span style="color:#f92672">.</span> Java中互斥锁的关键词为synchronized<span style="color:#f92672">.</span> 加锁的本质就是在锁对象的对象头中添加当前线程的ID<span style="color:#f92672">.</span>
<span style="color:#960050;background-color:#1e0010">```</span>java
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">X</span> <span style="color:#f92672">{</span>
    <span style="color:#75715e">//lock non-static method
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">synchronized</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">foo</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">//critical area
</span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>

    <span style="color:#75715e">//lock static method
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">synchronized</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">bar</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">//critical area
</span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>
    Object obj <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Object<span style="color:#f92672">();</span>
    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">baz</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">synchronized</span><span style="color:#f92672">(</span>obj<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#75715e">//critical area
</span><span style="color:#75715e"></span>        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span></code></pre></div>
<p>当synchronized修饰非静态方法时锁定当前实例对象this, 当synchronized修饰静态方法时锁定当前类的Class对象, 上面的例子可以等同为</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">X</span> <span style="color:#f92672">{</span>
    <span style="color:#75715e">//lock non-static method
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">synchronized</span><span style="color:#f92672">(</span><span style="color:#66d9ef">this</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">foo</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">//critical area
</span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>

    <span style="color:#75715e">//lock static method
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">synchronized</span><span style="color:#f92672">(</span>X<span style="color:#f92672">.</span><span style="color:#a6e22e">class</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">bar</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">//critical area
</span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span></code></pre></div>
<p>受保护资源与锁的关联关系应该是N:1的关系, 也就是说一把锁可以保护多个资源,而多把锁保护同一资源并没有可见性的保证.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SafeCalc</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">long</span> value <span style="color:#f92672">=</span> 0L<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">synchronized</span> <span style="color:#66d9ef">long</span> <span style="color:#a6e22e">get</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> value<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">synchronized</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">addOne</span><span style="color:#f92672">(){</span>
        value <span style="color:#f92672">+=</span> 1
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span></code></pre></div>
<p>简单的来说,我们可以用一把锁锁住所有需要的数据,但是这样会导致性能问题.因为一把锁会使所有的方法串行但很多方法是可以并行运行的. 用不同的锁对保护资源进行精细化管理,能够很大程度上提高性能.这种锁叫做<strong>细粒度锁</strong>. 使用<strong>细粒度锁</strong>可以提高并行度,但设计不良会导致<strong>死锁</strong>.</p>

<h5 id="死锁">死锁</h5>

<p>死锁指一组互相竞争资源的线程因互相等待,导致&rdquo;永久&rdquo;阻塞的现象. 触发死锁必须满足四个条件
- 互斥, 共享资源X和Y只能被一个线程占用.
- 占有且等待, 线程T已经取得共享资源X,在等待共享资源Y的时候,不释放共享资源X.
- 不可抢占,其他线程不能强行抢占线程T1占用的资源.
- 循环等待,线程T1等待线程T2占用的资源,线程T2等待线程T1占有的资源,就是循环等待.</p>

<p>破坏其中一条就可以避免死锁的发生. 一般较为实用的方法是破坏第二和第四条,第二条可以通过设置timeout或者循环等待所有条件就绪再占有来预防,第四条可以通过序列化共享资源的占用来避免.</p>

<h4 id="等待-通知-机制">&ldquo;等待-通知&rdquo;机制</h4>

<p>在并发冲突较小时,循环等待所有条件尚可行.但当冲突量增大时,这种自旋的方式会白白浪费CPU. 另外一种可行的方式当线程要求不满足时,线程阻塞自己进入阻塞状态. 当线程线程的要求被满足时,别的线程可以通知线程继续执行.</p>

<p>在Java语言里, &ldquo;等待-通知&rdquo;机制可以由Java语言内置的synchronized配合wait(), notify(), notifyAll()来实现.</p>

<p>每个互斥锁都有自己的<strong>等待队列</strong>,这个等待和互斥锁是一对一的关系. 在并发程序中,当一个线程进入临界区后,由于某个条件不满足,需要进入等待状态, Java对象的wait()方法就需要被调用. 当调用wait()方法后, 当前线程就会被阻塞并进入到<strong>等待队列</strong>.这个等待队列也是互斥锁的等待队列. 在线程进入<strong>等待队列</strong>的同时,会释放持有的互斥锁. 随后其他线程就有机会获得锁并进入临界区.</p>

<p>当条件满足时,可以通过notifyAll()方法, 这个方法会通知等待队列(<strong>对应互斥锁的等待队列</strong>)中的线程,告诉它<strong>条件曾经满足过</strong>. 但被通知的线程想要重新被执行,仍然需要获取到互斥锁.
&gt; 需要注意的是,wait(), notify(), notifyAll()这三个方法能够被调用的前提是已经获取了相应的互斥锁. 通常来说, 使用notifyAll(),并在wait()处设置重复判断是绝大多数的选择.</p>

<h4 id="编程中需要注意的三类问题-安全性问题-活跃性问题和性能问题">编程中需要注意的三类问题: 安全性问题, 活跃性问题和性能问题.</h4>

<h5 id="安全性问题">安全性问题</h5>

<p>安全性问题主要讨论的方向是方法或类是否线程安全. 所谓线程安全就是指程序按照预期的执行. 发生不安全的源头则是前面介绍过的可见性, 原子性和有序性问题.</p>

<p>但是只有一种情况需要具体分析这三个问题. 这种情况是<strong>存在共享数据并且该数据会发生变化,通俗的说就是多个线程会同时读写同一数据.</strong> 如果能够做到不共享数据或者数据状态不发生变化,就能够保证线程的安全性. 有许多方案是针对这个理论, 例如<strong>线程本地存储(Thread Local Storage)</strong>, 不变模式等等.</p>

<p>当<strong>必须共享数据</strong>时,多个线程同时访问同一数据且又一线程要写数据就会引发<strong>数据竞争(Data race)</strong>. 程序的执行结果依赖线程执行的顺序,就是所谓的<strong>竞态条件</strong>.</p>

<p>竞态条件（Race Condition）：计算的正确性取决于多个线程的交替执行时序时，就会发生竞态条件。常见的竞态条件有:
- 先检测后执行
- 两个线程同时修改统一数据</p>

<h5 id="活跃性问题">活跃性问题</h5>

<p>活跃性问题指的是某个操作无法执行下去. 常见的典型活跃性问题有三类:
- 死锁: 线程互相等待, 表现为线程永久阻塞
- 活锁: 线程并未发生阻塞, 但仍然会存在执行不下去的情况. 通常设置随机等待时间可以解决此类问题
- 饥饿: 线程因无法访问所需资源而无法执行下去的情况. 通常是因为CPU繁忙且线程优先级的差异导致的. 使用公平锁可以极大程度上解决此类问题.</p>

<h5 id="性能问题">性能问题</h5>

<p>我们应尽量使程序并行而提高性能. 有一个阿姆达尔(Amdahl)定律代表处理器并行计算之后效率提升的能力,它可以解决此类问题. 具体公式是:$S=1/(1-p)+\frac{p}{n})$. 在这个公式里, n为CPU的核数, p为并行百分比. 当n无穷大, 并行百分比为95%时, 最高也只能提高20倍的性能.</p>

<p>在方案设计层面,有两个方向可以用来提高性能.
- 第一, 最好的方案是避免用锁, 尽量多使用无锁的算法和数据结构. 这方面的相关技术有线程本地存储<strong>(Thread Local Storage TLS)</strong>, 写入复制(Copy-On-Write), 乐观锁等; Java并发包里的原子类也是无锁的数据结构, Disruptor则是无锁的内存队列.
- 第二, 可以尽量多的减少锁的持有时间, 互斥锁本质上就是将并行的程序串行化.实现这个方案的方法也很多,例如细粒度锁. ConcurrentHashMap它使用了所谓分段锁的技术;还有读写锁等.</p>

<p>在性能方面的度量指标有三个:
- 吞吐量: 指的是在单位时间内能处理请求的数量.
- 延迟: 指的是发出请求到收到响应这个过程的时间.
- 并发量.</p>

<h4 id="管程">管程</h4>

<p>管程(Monitor), 在Java中经常称之为监视器,在操作系统中被常称为管程.
&gt; 管程,指管理共享变量以及对共享变量的操作过程,使其支持并发.</p>

<h5 id="管程的发展-hasen模型-hoare模型-mesa模型">管程的发展-Hasen模型, Hoare模型, MESA模型</h5>

<p>并发编程领域有两大问题,两大核心问题:<strong>互斥</strong>和<strong>同步</strong>.
- 互斥: 同一时刻只允许一个线程访问共享资源.
- 同步: 线程之间如果通信与协作.</p>

<p>首先关注管程如何解决互斥问题. 其思路是将共享变量及其对共享变量的操作统一封装起来.</p>

<p>其次管程解决同步的方法需引入条件变量,每个条件变量都有一个对应的等待队列. 同时,只有一个线程允许进入管程.</p>

<p><img src="https://yangzhanghavefun.github.io/yzzhan/media/posts/monitor.png" alt="monitor illustration" /></p>

<h4 id="线程">线程</h4>

<h5 id="线程的生命周期">线程的生命周期</h5>

<p>通用的线程模型包括五种状态,通常以&rdquo;五态模型&rdquo;来描述. 这五态分别是:
- 初始状态: 线程已经被创建,但还不允许分配CPU执行.这个状态只存在于编程语言中, 换言之,这里的线程只是在编程语言层面被创建, 而在操作系统层面,真正的系统还没有创建.
- 可运行状态: 指线程可以分配CPU执行.
- 运行状态: 当空闲CPU分配给一个处于可运行状态的线程,被分配到CPU的线程的状态就转换成了可运行状态.
- 休眠状态: 运行的线程如果调用一个阻塞的API(阻塞的读取文件)或者等待某个事件(条件变量),那么线程状态就会转换到休眠状态,同时释放CPU的使用权. 当等待的时间出现并通知此线程,线程就会从休眠状态转换到可运行状态.
- 终止状态: 线程执行完或出现异常就会进入终止状态,终止状态的线程不会切换到其他任何状态. 这个状态意味着线程的生命周期结束了.</p>

<p><img src="https://yangzhanghavefun.github.io/yzzhan/media/posts/threadstate.png" alt="monitor illustration" /></p>

<h5 id="java中线程的生命周期">Java中线程的生命周期</h5>

<p>Java语言中线程共有六种状态, 分别是
1. NEW (初始化状态)
2. RUNNABLE (可运行/运行状态)
3. BLOCKED (阻塞状态)
4. WAITING (无时限等待)
5. TIMED_WAITING (有时限等待)
6. TERMINATED (终止等待)</p>

<p>BLOCKED, WAITING, TIMED_WAITING均属于线程的休眠状态, 换言之, 只要Java线程处于这三种状态之一, 那么这个线程就永远没有CPU的使用权. 这三种状态的划分是源于导致线程休眠的三个原因
- RUNNABLE -&gt; BLOCKED: 只有一种场景会触发这种转换, 就是线程等待synchronized的隐式锁. synchronized修饰的方法,代码块同一时刻只允许一个线程执行,其他线程只能等待,这种情况下,等待的线程就会从RUNNABLE转换到BLOCK状态.
需要注意的是, 当线程调用阻塞式API时,操作系统层面,线程会转换到休眠状态,但是在JVM层面, Java线程的状态不会发生变化.也就是说Java线程的状态依然会保持RUNNABLE状态. JVM层面不关心操作系统的调度状态因为在JVM看来,等待CPU使用权和等待I/O没有区别, 都是在等待某个系统资源,于是都属于RUNNABLE状态.
- RUNNABLE -&gt; WAITING: 有三种情况会发生这种状态的转化.
  - 第一种是在获得synchronized隐式锁后,调用无参数的wait()方法.
  - 第二种是调用无参数的Thread.join()方法.其中的join()是一种线程同步方法.例如一个线程对象thread A,当调用A.join().执行这条语句的线程会等待thread A执行完, 而等待中的这个线程,其状态会从RUNNABLE转换到WAITING. 当线程thread A执行完, 原来等待它的线程又会从WAITING变回RUNNABLE.
  - 第三种情况是调用LockSupport.park()方法.Java并发包中的锁都是基于其实现的.调用LockSupport.park()方法,当前线程会阻塞,线程的状态会从RUNNABLE转换到WAITING. 调用LockSupport.unpack(Thread thread)可以唤醒目标线程, 目标线程的状态会从WAITING状态转换到RUNNABLE.
- RUNNABLE -&gt; TIMED_WAITING:
  - 带超时参数的Thread.sleep(long millis)
  - 获得synchronized隐式锁的线程, 调用wait(long timeout)
  - 调用带超时参数的Thread.join()
  - 调用带超时参数的LockSupport.parkNanos(Object blocker, long deadline)方法
  - 调用带超时参数的LockSupport.parkUntil(long deadline)
- NEW -&gt; RUNNABLE: 可以分为NEW线程的部分和NEW-&gt;RUNNABLE部分.
  - NEW线程部分可以通过继承Thread对象或者实现Runnable接口.
  - NEW-&gt;RUNNABLE只能通过myThread.start()方法.
- RUNNABLE -&gt; TERMINATED: 当线程执行完run()方法之后,线程的状态转化为TERMINATED,或者当执行run()方法时有异常抛出. 当我们想主动结束线程时,建议使用interrupt()方法. stop()已经被标记为了@Deprecated.</p>

<p>stop()方法和interrupt()方法的区别是stop()方法会直接杀死线程,被杀死的线程不会自动释放ReentrantLock锁,致使其他线程也无法获取到相应的锁.这样的方法因为太危险而被不建议使用,类似的还有suspend()和resume()方法.</p>

<p>interrupt()方法只是通知线程,线程可以选择忽略或者继续执行一些收尾操作. 线程由两种方法接收到通知.一种是异常,一种是主动监测
- 异常:
  - 当线程处于WAITING, TIMED_WAITING状态时,如果其他线程调用线程A的interrupt()方法,会使线程A返回到RUNNABLE的状态, 同时线程A的代码会触发InterruptedException异常. 上面提到过的wait(), join(), sleep()等方法的签名都有throws InterruptedException这个异常. 这个异常的触发条件是: 其他线程调用了该线程的interrupt()方法.
  - 当线程处于RUNNABLE状态时,并且阻塞在java.nio.channels.InterruptibleChannel上时, 如果其他线程调用线程A的interrupt()方法, 线程A会触发java.nio.channels.ClosedByInterruptException这个异常.
  - 当线程处于RUNNABLE状态时,并且阻塞在java.nio.channels.Selector上时,如果其他线程调用线程A的interrupt()方法,线程A的java.nio.channels.Selector会立即返回.
- 主动监测: 如果线程处于RUNNABLE状态,并且没有阻塞在某个I/O操作上,这时依赖线程A主动监测中断状态.如果其他线程调用线程的interrupt()方法,那么线程可以通过isInterrupted()方法,监测是不是自己被中断了.</p>

<h4 id="并发量">并发量</h4>

<p>在并发编程领域,提升性能本质上是提升硬件的利用率, 提升I/O的利用率和CPU的利用率. 最佳的线程数量的决定可以分为CPU密集型计算场景和I/O密集型计算场景.
- CPU密集型计算场景: 理论上&rdquo;线程的数量=CPU核数&rdquo;是最适合的,但在工程上,一般会设置为#CPU+1,因为偶尔当内存失效或其他原因导致阻塞的时候,额外的线程可以顶上来保证CPU的利用率.
- I/O密集型计算场景: 最佳的线程数量与程序中CPU计算和I/O操作的耗时比相关的.
 &gt; 最佳线程数 = 1+ (I/O耗时/CPU耗时)</p>

<h4 id="局部变量-线程封闭">局部变量 &ndash; 线程封闭</h4>

<p>方法里的局部变量, 因为不会和其他线程共享, 所以没有并发问题. 这是一个解决并发问题的重要思路和技术,称之为<strong>线程封闭</strong>.
&gt; 线程封闭: 仅在单线程内访问数据.</p>

<p>采用线程封闭的案例非常多,例如在数据库连接池里获取的连接Connection, 在JDBC里没有要求这个Connection必须是线程安全的. 数据库连接池通过线程封闭技术,保证一个Connection一旦被一个线程获取之后,在这个线程关闭Connection之前的这段时间里, 不会再分配给其他线程,从而保证了Connection不会有并发问题.</p>

<h3 id="java-util-concurrent-juc并发包详解">Java.util.Concurrent JUC并发包详解</h3>

<h4 id="lock和condition">Lock和Condition</h4>

<p>JUC通过lock和condition这两个接口来重新实现管程, 其中Lock用于解决互斥问题,Condition用于解决同步问题.</p>

<h5 id="重造管程而不使用自带的synchronized的理由">重造管程而不使用自带的synchronized的理由</h5>

<ul>
<li>能够相应中断. synchronized的问题是, 持有锁A后,如果尝试获取锁B失败, 那么线程就进入阻塞状态.一旦发生死锁, 就没有任何机会来唤醒阻塞的线程. 我们的期望是如果处于阻塞状态的线程能够相应中断信号, 换言之当我们给阻塞的线程发送中断信号时,线程能够被唤醒,那它就有机会释放锁A,也就破坏了不可抢占的条件.</li>
<li>支持超时. 如果线程在一段时间内都没有获取到锁, 不是进入阻塞状态而是返回一个错误,那这个线程也有机会释放曾经的锁.</li>
<li>非租塞的获取锁. 如果尝试获取锁失败可以立即返回.</li>
</ul>

<p>这三个理由构成了API上就是Lock接口的三个方法.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Java" data-lang="Java"><span style="color:#75715e">// 支持中断的API
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">lockInterruptibly</span><span style="color:#f92672">()</span> <span style="color:#66d9ef">throws</span> InterruptedException<span style="color:#f92672">;</span>
<span style="color:#75715e">// 支持超时的API
</span><span style="color:#75715e"></span><span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">tryLock</span><span style="color:#f92672">(</span><span style="color:#66d9ef">long</span> time<span style="color:#f92672">,</span> TimeUnit unit<span style="color:#f92672">)</span> <span style="color:#66d9ef">throws</span> InterruptedException<span style="color:#f92672">;</span>
<span style="color:#75715e">// 支持非阻塞获取锁的API
</span><span style="color:#75715e"></span><span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">tryLock</span><span style="color:#f92672">();</span></code></pre></div>
<p>JUC里用锁的经典范例就是try{}finally{}</p>

<h5 id="如何保证可见性">如何保证可见性</h5>
</article>
    <footer class="post-footer">
      
      <ul class="post-tags">
        
          <li><a href="https://yangzhanghavefun.github.io/yzzhan/tags/java"><span class="tag">Java</span></a></li>
        
          <li><a href="https://yangzhanghavefun.github.io/yzzhan/tags/concurrency"><span class="tag">Concurrency</span></a></li>
        
      </ul>
      
      <p class="post-copyright">
        © This post is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License，please give source if you wish to quote or reproduce.
      </p>
    </footer>
    
      <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "disqus_shortname" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
      
    
  </section>
  
<footer class="site-footer">
  <p>© 2017-2019 Yzzhan Tech Repo</p>
  <p>Powered by <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> with theme <a href="https://github.com/laozhu/hugo-nuo" target="_blank" rel="noopener">Nuo</a>.</p>
  
</footer>


<script src="https://cdn.jsdelivr.net/npm/smooth-scroll@15.0.0/dist/smooth-scroll.min.js"></script>



<script async src="https://cdn.jsdelivr.net/npm/video.js@7.3.0/dist/video.min.js"></script>




<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$','$'], ['\\(','\\)']],
      displayMath: [['$$','$$'], ['\\[','\\]']],
      processEscapes: true,
      processEnvironments: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
      TeX: { equationNumbers: { autoNumber: "AMS" },
      extensions: ["AMSmath.js", "AMSsymbols.js"] }
    },
  });
</script>
<script type="text/x-mathjax-config">
  // Fix <code> tags after MathJax finishes running. This is a
  // hack to overcome a shortcoming of Markdown. Discussion at
  // https://github.com/mojombo/jekyll/issues/199
  MathJax.Hub.Queue(() => {
    MathJax.Hub.getAllJax().map(v => v.SourceElement().parentNode.className += ' has-jax');
  });
</script>



<script src="https://yangzhanghavefun.github.io/yzzhan/scripts/index.min.js"></script>

<script>
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('\/service-worker.js').then(function() {
      console.log('[ServiceWorker] Registered');
    });
  }
</script>




<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-XXXXXXXX-X', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>







  </body>
</html>
