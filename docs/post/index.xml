<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Yzzhan Tech Repo</title>
    <link>https://yangzhanghavefun.github.io/yzzhan/post/</link>
    <description>Recent content in Posts on Yzzhan Tech Repo</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>© This post is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License，please give source if you wish to quote or reproduce.</copyright>
    <lastBuildDate>Wed, 17 Apr 2019 01:37:56 +0800</lastBuildDate>
    
	<atom:link href="https://yangzhanghavefun.github.io/yzzhan/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Notes for Advanced Database System(COMP90050)</title>
      <link>https://yangzhanghavefun.github.io/yzzhan/post/adb/</link>
      <pubDate>Wed, 17 Apr 2019 01:37:56 +0800</pubDate>
      
      <guid>https://yangzhanghavefun.github.io/yzzhan/post/adb/</guid>
      <description>Different types of Database System There are multiple database technologies related to database structure. - Simple file systems like Unix File System - Relational Database System(RDBS) - Object Oriented(oo) Database System - Deductive Database System(DDBS) - Key-Value pair based Database System - NoSQL
Different types of Database Architectures  Centralised Database System Client-Server Distributed Database System World Wide Web Grid Computing/Databases that lead to Cloud Computing/Data Centres P2P Databases  Basic Memory Knowledge Memory Hierarchy In single core circumstance, the CPU communication case is : In muliple cores circumstance, the CPU communication case is : In Inter i7 Block Diagram, the CPU interaction is: Transaction Processing  A transaction is collection of operations that need to be performed on the physical and abstract application state.</description>
    </item>
    
    <item>
      <title>Notes for distributed system preparation(COMP90024)</title>
      <link>https://yangzhanghavefun.github.io/yzzhan/post/clustercomputing/</link>
      <pubDate>Wed, 17 Apr 2019 01:37:56 +0800</pubDate>
      
      <guid>https://yangzhanghavefun.github.io/yzzhan/post/clustercomputing/</guid>
      <description>Auto-deploying by Ansible Docker Background Introduction Virtualization vs. Containerization The advantages of virtualization, such as application containment and horizontal scalability come at a cost: resources.
The containerization allows virtual instances to share a single host OS to reduce wasted resources since each container only holds the application and related binaries. The rest are shared among the containers. Container Container is similar to concept of resouce isolation and allocation as a virtual machine.</description>
    </item>
    
    <item>
      <title>对操作系统中并发的读书总结</title>
      <link>https://yangzhanghavefun.github.io/yzzhan/post/concurrencyinoperatingsystem/</link>
      <pubDate>Wed, 17 Apr 2019 01:37:56 +0800</pubDate>
      
      <guid>https://yangzhanghavefun.github.io/yzzhan/post/concurrencyinoperatingsystem/</guid>
      <description> 这篇文章是对&amp;lt;&amp;gt;关于进程,线程等并发相关的知识点的总结. 以下内容分为四个部分, 进程的描述和控制, 线程, 并发性, 并发中的死锁和饥饿.
进程的描述和控制 线程 并发性 并发中的死锁和饥饿 </description>
    </item>
    
    <item>
      <title>对深入理解java虚拟机的读书总结</title>
      <link>https://yangzhanghavefun.github.io/yzzhan/post/jvm/</link>
      <pubDate>Wed, 17 Apr 2019 01:37:56 +0800</pubDate>
      
      <guid>https://yangzhanghavefun.github.io/yzzhan/post/jvm/</guid>
      <description>这篇文章是关于/&amp;lt;&amp;lt;深入理解Java虚拟机第二版&amp;gt;&amp;gt;的全书总结.总结的目录也与原书的章节吻合.
Part 1(Java 概括) Java技术体系的组成部分 - Java 程序设计语言 - 各种硬件平台上的Java虚拟机 - Class文件格式 - Java API 类库 - 来自商业机构和开源社区的第三方Java类库
JDK(Java Development Kit) 包括Java 程序设计语言, Java虚拟机, JavaAPI类库这三部分。是用于支持Java程序开发的最小环境
JRE(Java Runtime Environment) 包括Java SE API子集和Java虚拟机这两个部分。是支持Java程序运行的标准环境。
Java的四个平台 - Java Card: 支持一些Java小程序(Applets) 运行在小内存设备（如智能卡）上的平台 - Java ME(Micro Edition): 支持Java程序运行在移动终端上的平台，是对Java API有所精简并加入了针对移动终端支持，以前称为J2ME。 - Java SE（Standard Edition）: 支持面向桌面级应用。 - Java EE (Enterprise Edition) : 支持使用多层架构的企业应用的Java平台，除了提供Java SE API外，还对其做了大量的扩充和部署支持。
Part 2（自动内存管理机制） Java内存区域与内存溢出异常 运行时的数据区域 Java虚拟机在执行Java程序的过程中会把所管理的内存划分为若干个不同的数据区域. 1. 程序计数器(Program Counter Register) * 当前线程所执行的字节码的行号指示器 * 字节码解释器工作时通过程序计数器来选取下一条需要执行的字节码指令.</description>
    </item>
    
    <item>
      <title>杂记</title>
      <link>https://yangzhanghavefun.github.io/yzzhan/post/zaji/</link>
      <pubDate>Wed, 17 Apr 2019 01:37:56 +0800</pubDate>
      
      <guid>https://yangzhanghavefun.github.io/yzzhan/post/zaji/</guid>
      <description>老子曰: 死而不亡者寿. &amp;ldquo;&amp;lsquo;太上有立德，其次有立功，其次有立言&amp;rsquo;，虽久不废，此之谓不朽。&amp;rdquo; &amp;mdash;&amp;lt;&amp;lt;左传&amp;gt;&amp;gt;</description>
    </item>
    
    <item>
      <title>Java知识点杂记</title>
      <link>https://yangzhanghavefun.github.io/yzzhan/post/javarandomnote/</link>
      <pubDate>Mon, 15 Apr 2019 01:37:56 +0800</pubDate>
      
      <guid>https://yangzhanghavefun.github.io/yzzhan/post/javarandomnote/</guid>
      <description></description>
    </item>
    
    <item>
      <title>深入理解java并发知识的归纳</title>
      <link>https://yangzhanghavefun.github.io/yzzhan/post/javaconcurrency/</link>
      <pubDate>Sun, 14 Apr 2019 01:37:56 +0800</pubDate>
      
      <guid>https://yangzhanghavefun.github.io/yzzhan/post/javaconcurrency/</guid>
      <description>多线程 在Java中创建线程的方式有且仅有一种就是Thread myThread = new Thread();</description>
    </item>
    
    <item>
      <title>Data Structures and Algorithm in Java</title>
      <link>https://yangzhanghavefun.github.io/yzzhan/post/javadatastructureandalgorithm/</link>
      <pubDate>Fri, 12 Apr 2019 01:37:56 +0800</pubDate>
      
      <guid>https://yangzhanghavefun.github.io/yzzhan/post/javadatastructureandalgorithm/</guid>
      <description>Data Structure and Algorithm Iterators Suppose we want to traverse a list, performing some operations on certain links.
As users of a list, what we need is access to reference that can point to any arbitray link. This allows us to examine or modify the link. We should be able to increment the reference so we can traverse along the list, looking at each link in turn, and we should be able to access the link pointed to by the reference.</description>
    </item>
    
    <item>
      <title>对学习过的Web Security的总结</title>
      <link>https://yangzhanghavefun.github.io/yzzhan/post/websecurity/</link>
      <pubDate>Thu, 11 Apr 2019 01:37:56 +0800</pubDate>
      
      <guid>https://yangzhanghavefun.github.io/yzzhan/post/websecurity/</guid>
      <description> 横向越权和纵向越权  横向越权: 攻击者尝试访问与他拥有相同权限的用户的资源.
纵向越权: 低级别攻击者尝试访问高级别用户的资源.
 </description>
    </item>
    
    <item>
      <title>对用过的Linux(Centos7.0&#43;)指令的总结</title>
      <link>https://yangzhanghavefun.github.io/yzzhan/post/linuxreview/</link>
      <pubDate>Thu, 11 Apr 2019 01:37:56 +0800</pubDate>
      
      <guid>https://yangzhanghavefun.github.io/yzzhan/post/linuxreview/</guid>
      <description>开启防火墙对指定Port外界访问的权限 例如开启数据库port3306的port
!/bin/bash /sbin/iptables -I INPUT -p tcp --dport 3306 -j ACCEPT service iptables save service iptables restart 如果iptables save不能用则使用以下命令
# It is possible to go back to a more classic iptables setup. First, stop and mask the firewalld service: systemctl stop firewalld systemctl mask firewalld # Then, install the iptables-services package: yum install iptables-services # Enable the service at boot-time: systemctl enable iptables # Managing the service systemctl [stop|start|restart] iptables # Saving your firewall rules can be done as follows: service iptables save # check your listenning ports with: netstat -nat |grep :3306 重装mariadb 重装database server的时候, 任何残留的mysql文件都会导致新安装的mariadb.</description>
    </item>
    
    <item>
      <title>FSP and LTSA</title>
      <link>https://yangzhanghavefun.github.io/yzzhan/post/fsp/</link>
      <pubDate>Tue, 02 Apr 2019 01:37:56 +0800</pubDate>
      
      <guid>https://yangzhanghavefun.github.io/yzzhan/post/fsp/</guid>
      <description>Introduction to FSP When dealing with large code bases, identifying, locating, and removing concurrency problems can be a nightmare. The size of the system and the number of possible interleavings and synchronisations become so large that it is difficult to even understand a single problem, isolate it, figure out how to fix it, or prevent it in the first place.
s. In particular, we will look at a language called Finite State Processes (FSP), based on the well-known Communicating Sequential Processes (CSP) and Calculus of Communicating Systems (CCS).</description>
    </item>
    
    <item>
      <title>Java拾遗</title>
      <link>https://yangzhanghavefun.github.io/yzzhan/post/javashiyi/</link>
      <pubDate>Tue, 02 Apr 2019 01:37:56 +0800</pubDate>
      
      <guid>https://yangzhanghavefun.github.io/yzzhan/post/javashiyi/</guid>
      <description>Content: 面向对象和面向过程 什么是fast-fail和fail-safe Java是如何做到平台无关的 面向对象和面向过程的区别与面向对象的三大基本特征和五大基本原则  面向过程指把task分解成一个一个的步骤, 每个步骤用函数来实现,依次调用即可.
进一步解释:在软件开发初期,程序编写都是以算法为核心,程序员会把数据和过程分别作为独立的部分来考虑, 数据代表空间中的客体,程序代码则用于处理这些数据,这种直接站在计算机的角度去抽象问题和解决问题的思想称为面向过程的编程思想.
面向对象指把task分解成一个一个的步骤之后, 并对各个步骤进行相应的抽象, 形成对象, 同时建立对象之间的联系. 随后组合解决问题. 在面向对象编程的过程中,要把步骤进行相应的抽象形成对象, 对象封装了相应的属性和方法. 最后基于对象和对象的能力来完成业务逻辑的实现.
进一步解释:面向对象的编程思想是站在现实角度去抽象和解决问题,它把数据和行为都看做是对象的一部分, 这样可以让程序员能以符合现实世界的思维方式来编写和组织程序.
面向对象的三个基本特征 - 封装 - 继承 - 多态 &amp;gt;封装(Encapsulation):是指利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体，数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。系统的其他对象只能通过包裹在数据外面的已经授权的操作来与这个封装的对象进行交流和交互。也就是说用户是无需知道对象内部的细节，但可以通过该对象对外的提供的接口来访问该对象。
 继承(Inheritance): 继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码，能够大大的提高开发的效率。 继承所描述的是“is-a”的关系，如果有两个对象A和B，若可以描述为“A是B”，则可以表示A继承B，其中B是被继承者称之为父类或者超类，A是继承者称之为子类或者派生类。
 《Think in java》：问一问自己是否需要从子类向父类进行向上转型。如果必须向上转型，则继承是必要的，但是如果不需要，则应当好好考虑自己是否需要继承。
 多态(Polymorphism): 所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。
 对于面向对象而言，多态分为编译时多态和运行时多态。其中编辑时多态是静态的，主要是指方法的重载，它是根据参数列表的不同来区分不同的函数，通过编辑之后会变成两个不同的函数，在运行时谈不上多态。而运行时多态是动态的，它是通过动态绑定来实现的，也就是我们所说的多态性。
总结:OOP是一种编程思想,一种程序范式,提倡用类来实现对象,用继承来实现关系,用封装来实现类所提供的功能,用多态来实现角色的动态转换
原文：https://blog.csdn.net/jianyuerensheng/article/details/51602015
面向对象的五个基本原则 &amp;gt;单一职责原则(Single-Resposibility Principle): 其核心思想为：一个类，最好只做一件事，只有一个引起它的变化。单一职责原则可以看做是低耦合、高内聚在面向对象原则上的引申，将职责定义为引起变化的原因，以提高内聚性来减少引起变化的原因。职责过多，可能引起它变化的原因就越多，这将导致职责依赖，相互之间就产生影响，从而大大损伤其内聚性和耦合度。通常意义下的单一职责，就是指只有一种单一功能，不要为类实现过多的功能点，以保证实体只有一个引起它变化的原因。 专注，是一个人优良的品质；同样的，单一也是一个类的优良设计。交杂不清的职责将使得代码看起来特别别扭牵一发而动全身，有失美感和必然导致丑陋的系统错误风险。
 开放封闭原则(Open-Closed principle): 其核心思想是：软件实体应该是可扩展的，而不可修改的。也就是，对扩展开放，对修改封闭的。开放封闭原则主要体现在两个方面1、对扩展开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。2、对修改封闭，意味着类一旦设计完成，就可以独立完成其工作，而不要对其进行任何尝试的修改。 实现开开放封闭原则的核心思想就是对抽象编程，而不对具体编程，因为抽象相对稳定。让类依赖于固定的抽象，所以修改就是封闭的；而通过面向对象的继承和多态机制，又可以实现对抽象类的继承，通过覆写其方法来改变固有行为，实现新的拓展方法，所以就是开放的。 “需求总是变化”没有不变的软件，所以就需要用封闭开放原则来封闭变化满足需求，同时还能保持软件内部的封装体系稳定，不被需求的变化影响。
Liskov替换原则(Liskov-Substituion Principle): 其核心思想是：子类必须能够替换其基类。这一思想体现为对继承机制的约束规范，只有子类能够替换基类时，才能保证系统在运行期内识别子类，这是保证继承复用的基础。在父类和子类的具体行为中，必须严格把握继承层次中的关系和特征，将基类替换为子类，程序的行为不会发生任何变化。同时，这一约束反过来则是不成立的，子类可以替换基类，但是基类不一定能替换子类。 Liskov替换原则，主要着眼于对抽象和多态建立在继承的基础上，因此只有遵循了Liskov替换原则，才能保证继承复用是可靠地。实现的方法是面向接口编程：将公共部分抽象为基类接口或抽象类，通过Extract Abstract Class，在子类中通过覆写父类的方法实现新的方式支持同样的职责。 Liskov替换原则是关于继承机制的设计原则，违反了Liskov替换原则就必然导致违反开放封闭原则。 Liskov替换原则能够保证系统具有良好的拓展性，同时实现基于多态的抽象机制，能够减少代码冗余，避免运行期的类型判别。
依赖倒置原则(Dependecy-Inversion Principle): 其核心思想是：依赖于抽象。具体而言就是高层模块不依赖于底层模块，二者都同依赖于抽象；抽象不依赖于具体，具体依赖于抽象。 我们知道，依赖一定会存在于类与类、模块与模块之间。当两个模块之间存在紧密的耦合关系时，最好的方法就是分离接口和实现：在依赖之间定义一个抽象的接口使得高层模块调用接口，而底层模块实现接口的定义，以此来有效控制耦合关系，达到依赖于抽象的设计目标。 抽象的稳定性决定了系统的稳定性，因为抽象是不变的，依赖于抽象是面向对象设计的精髓，也是依赖倒置原则的核心。 依赖于抽象是一个通用的原则，而某些时候依赖于细节则是在所难免的，必须权衡在抽象和具体之间的取舍，方法不是一层不变的。依赖于抽象，就是对接口编程，不要对实现编程。
接口隔离原则(Interface-Segregation Principle): 其核心思想是：使用多个小的专门的接口，而不要使用一个大的总接口。 具体而言，接口隔离原则体现在：接口应该是内聚的，应该避免“胖”接口。一个类对另外一个类的依赖应该建立在最小的接口上，不要强迫依赖不用的方法，这是一种接口污染。 接口有效地将细节和抽象隔离，体现了对抽象编程的一切好处，接口隔离强调接口的单一性。而胖接口存在明显的弊端，会导致实现的类型必须完全实现接口的所有方法、属性等；而某些时候，实现类型并非需要所有的接口定义，在设计上这是“浪费”，而且在实施上这会带来潜在的问题，对胖接口的修改将导致一连串的客户端程序需要修改，有时候这是一种灾难。在这种情况下，将胖接口分解为多个特点的定制化方法，使得客户端仅仅依赖于它们的实际调用的方法，从而解除了客户端不会依赖于它们不用的方法。 分离的手段主要有以下两种：1、委托分离，通过增加一个新的类型来委托客户的请求，隔离客户和接口的直接依赖，但是会增加系统的开销。2、多重继承分离，通过接口多继承来实现客户的需求，这种方式是较好的。</description>
    </item>
    
    <item>
      <title>Java面试的知识储备</title>
      <link>https://yangzhanghavefun.github.io/yzzhan/post/java-interview-preparation/</link>
      <pubDate>Sat, 16 Mar 2019 01:37:56 +0800</pubDate>
      
      <guid>https://yangzhanghavefun.github.io/yzzhan/post/java-interview-preparation/</guid>
      <description>#Content 1. Difference between Hashtable and HashMap
1.Difference between Hashtable and HashMap  ### 作者不一样。。。  Hashtable阵容
* @author Arthur van Hoff * @author Josh Bloch * @author Neal Gafter HashMap阵容
* @author Arthur van Hoff * @author Josh Bloch * @author Neal Gafter * @author Doug Lea Doug Lea大神写了util.concurrent包。 并著有并发编程圣经Concurrent Programming in Java: Design Principles and Patterns 他的个人主页 http://g.oswego.edu/ Josh Bloch 著有Effective Java, Arthur vanHoff最早任职于硅谷的SunMicrosystems公司，从事Java程序语言的早期开发工作 Neal Gafter是Java SE 4和5语言增强的主要设计者和实现者</description>
    </item>
    
    <item>
      <title>对Elastic Search的实现和理解</title>
      <link>https://yangzhanghavefun.github.io/yzzhan/post/search_engine/</link>
      <pubDate>Sat, 16 Mar 2019 01:37:56 +0800</pubDate>
      
      <guid>https://yangzhanghavefun.github.io/yzzhan/post/search_engine/</guid>
      <description> Elastic Search Engine Specification  Coding Language : python FrameWork : django + scrapy Scrapied website: www.zhihu.com www.jobbole.com www.lagou.com  Knowledge Preparation 浏览器 driver 由于知乎等网站需要登录后才能访问所需要的内容，于是我们需要安装chrome driver 和 selenium去模拟登录
下载链接 http://chromedriver.chromium.org/downloads 但是，直接使用还是凉凉， 因为服务器会从Chrome driver的某些js文件中检测出这是个driver不是正常浏览器，然后返回403.我们的解决方法是开启chrome remote debug 模式 配置 关闭所有chrome正在运行的实例 在Cmd里找到Chrome.exe所在的目录，输入chrome.exe &amp;ndash;remote-debugging-port=9222 然后访问127.0.0.1:9222/json
ElasticSearch 概念  集群： 一个或多个节点组织在一起 节点： 一个节点是集群中的一个服务器，由一个名字来标识 分片： 将索引划分为多份的能力，允许水平分割和扩展容量，多个分片响应请求，提高性能和吞吐量 副本： 创建分片的一份或多份的能力，在一个节点失败是其余节点可以顶上     ElasticSearch Mysql     index(索引) 数据库   type(类型) 表   documents(文档) 行   Fields 列    </description>
    </item>
    
    <item>
      <title>如何在python环境实现并发和一些对并发的理解</title>
      <link>https://yangzhanghavefun.github.io/yzzhan/post/coroutine/</link>
      <pubDate>Wed, 16 Jan 2019 01:37:56 +0800</pubDate>
      
      <guid>https://yangzhanghavefun.github.io/yzzhan/post/coroutine/</guid>
      <description>概念： 并发，并行，同步，异步，阻塞， 非阻塞 并发的开发 &amp;mdash; 回调 + 事件循环 + select(poll,epoll) import socket from urllib.parse import urlparse from selectors import DefaultSelector, EVENT_READ, EVENT_WRITE selector = DefaultSelector() urls = [&amp;#34;https://www.baidu.com&amp;#34;, &amp;#34;https://www.baidu.com&amp;#34;] stop = False class Fetcher: def connected(self, key): selector.unregister(key.fd) self.client.send(&amp;#34;GET {} HTTP/1.1\r\nHost:{}\r\nConnection:close\r\n\r\n&amp;#34;.format(self.path, self.host).encode(&amp;#34;utf8&amp;#34;)) # 当写入成功时，我们继续注册selector用以接受请求的回答 selector.register(self.client.fileno(), EVENT_READ, self.received) def received(self, key): d = self.client.recv(1024) if d: self.data += d else: selector.unregister(key.fd) data = self.data.decode(&amp;#34;utf8&amp;#34;) html_data = data.split(&amp;#34;\r\n\r\n&amp;#34;)[1] print(html_data) self.client.close() urls.remove(self.next_url) if not urls: global stop stop = True def get_url(self, url): self.</description>
    </item>
    
    <item>
      <title>实现高并发并深入理解asyncio内置包</title>
      <link>https://yangzhanghavefun.github.io/yzzhan/post/asyncio/</link>
      <pubDate>Wed, 16 Jan 2019 01:37:56 +0800</pubDate>
      
      <guid>https://yangzhanghavefun.github.io/yzzhan/post/asyncio/</guid>
      <description>Package Asynic 实现协程和io多路复用，python提供了一个内置包&amp;mdash;asyncio去简化 回调+事件循环(核心)+select(poll,epoll)这个流程。
在async包的内部，已经实现了事件循环，并且为了把generator和coroutine方法区分开，python引入了两个关键词 async和await
-async用于方法开头，声明此方法为协程方法
-await用于方法中，声明需要异步处理的地方，类似于生成器里的yield from
-同时方法末尾可提供一个返回值。
-在协程方法中不可以使用同步/阻塞的方法或函数(eg: time.sleep() &amp;mdash;&amp;gt; async.sleep())，否则会使异步编程无意义
Adding tasks into loop  我们实例化loop &amp;mdash;&amp;gt; loop = asyncio.get_event_loop()
 然后列出需要异步实现的Tasks. 此时我们有两种实现方法。第一我们可以把我们的task转成Future object eg: ``python futures = [asyncio.ensure_future(get_html(&amp;quot;www.baidu.com/{}&amp;quot;.format(i))) for i in range(100)]
  for future in futures: future.add_done_callback(callbakck)
 这个方法与线程池的实现方法和原理相同，在future object里存着返回的值，并用result()可以调出。并且，future object支持增加回调函数.当我们的回调函数需要输入参数时，我们需要用到包装函数partial ---- from functools import partial ```python for future in futures: future.add_done_callback(partial(callbakck, &amp;quot;www.baidu.com&amp;quot;))  或者用async.wait, async.gather包装
task_group_1 = [get_html(&amp;#34;www.bilibili.com/{}&amp;#34;.format(i))for i in range(10)] task_group_2 = [get_html(&amp;#34;www.</description>
    </item>
    
    <item>
      <title>对多线程的理解和深入理解Future源码</title>
      <link>https://yangzhanghavefun.github.io/yzzhan/post/multithreads/</link>
      <pubDate>Wed, 16 Jan 2019 01:37:56 +0800</pubDate>
      
      <guid>https://yangzhanghavefun.github.io/yzzhan/post/multithreads/</guid>
      <description>Basic Concepts related to thread and process Multiple ways to implement the multithreading project in python Queue, Lock, RLock, Condition and Semorpher # GIL---global interpreter lock import threading from queue import Queue import time # Communication between threads # 1. Share Variables sum = 0 lock = threading.Lock() def add_glo(lock): global sum for i in range(1000000): lock.acquire() sum += 1 lock.release() def dec_glo(lock): global sum for i in range(1000000): lock.</description>
    </item>
    
    <item>
      <title>对生成器和协程的理解</title>
      <link>https://yangzhanghavefun.github.io/yzzhan/post/generator/</link>
      <pubDate>Wed, 16 Jan 2019 01:37:56 +0800</pubDate>
      
      <guid>https://yangzhanghavefun.github.io/yzzhan/post/generator/</guid>
      <description>迭代器和迭代协议 我们知道实现下标的操作是基于getitem这个协议
 可迭代类型
 迭代器 #
  http://39.96.12.43:8000/alipay/return/?charset=utf-8&amp;amp;out_trade_no=201702022ssswq&amp;amp;method=alipay.trade.page.pay.return&amp;amp;total_amount=100.00&amp;amp;sign=X59PxIrSunlz4IqhjBbHb1dzoPCChJbRN720AMn74kyDT54wkSCt1XIK%2B55PiWWU%2F3ytN7yn6Imt%2BaODtjPRF15VCCYrxDdby8tnBCxI3A7owvU9urvH5CwbHuvxE047ceHmVx44lA5%2BE9RUtUwd%2B%2Ba0omTdi83%2Fc6CPWlKLJPq1d5HIbJg8HEnPGqHObJadOkmpEpDcVRQyy74TibmAau9ZfHc4u4%2BuWyIzPJpnsEqjlhsaYraJdIUIEuG5qnO4dpNS66wyX%2FP7Ri3eb1JufklIl3CX9718XYf6IxQ5vrTjmw0PzieAH6ZvavYm2o%2BrH4H01D71mtVzQVJUc3Bqqg%3D%3D&amp;amp;trade_no=2019021722001471690500769031&amp;amp;auth_app_id=2016092400589241&amp;amp;version=1.0&amp;amp;app_id=2016092400589241&amp;amp;sign_type=RSA2&amp;amp;seller_id=2088102177131773&amp;amp;timestamp=2019-02-17+12%3A34%3A09
https://openapi.alipaydev.com/gateway.do?app_id=&amp;amp;biz_content=%7B%22subject%22%3A%2220190217220809366%22%2C%22out_trade_no%22%3A%2220190217220809366%22%2C%22total_amount%22%3A200.0%2C%22product_code%22%3A%22FAST_INSTANT_TRADE_PAY%22%7D&amp;amp;charset=utf-8&amp;amp;method=alipay.trade.page.pay&amp;amp;notify_url=http%3A%2F%2F39.96.12.43%3A8000%2Falipay%2Freturn%2F&amp;amp;return_url=http%3A%2F%2F39.96.12.43%3A8000%2Falipay%2Freturn%2F&amp;amp;sign_type=RSA2&amp;amp;timestamp=2019-02-17+22%3A26%3A09&amp;amp;version=1.0&amp;amp;sign=UuoIjRxBAdVb67zQzLPmZxO3OrDkJvlsh0UCw3OzLDre2HrIrNJaPCbWvtqC7RRvVwMVKnAaCeXGSU9HTHEvnP9Bi4oEevpeMZIcOtMBO9EMKbB1nzk84ROtP4rC6lEqZOeyvOJsi4NHFEh4bO8OXVvK2%2Fb34J9YtplSo5Ucl6qJDHTREjWf3mJ%2FwU4knougrSR269ze0dTGr%2FkjppldVJWjKtbcI5MOy1BrymInhw6qNq9zWQxAS7xpdNpUEWA0DESTK%2B5KQVzRvavGlgqHeFCUCkGH8UoVhMx2wRiLF9ylX4QpZ85kfbQb3uZ%2FmpBHjOjlunEjy5Vj3xypfGGlqg%3D%3D</description>
    </item>
    
    <item>
      <title>Detailed algorithm For Hash Function</title>
      <link>https://yangzhanghavefun.github.io/yzzhan/post/hash_function/</link>
      <pubDate>Sat, 12 Jan 2019 01:37:56 +0800</pubDate>
      
      <guid>https://yangzhanghavefun.github.io/yzzhan/post/hash_function/</guid>
      <description>Hash Function There will be three topics related to HASH FUNCTION in this article. Generally, Hash Function could be divided into two part, Block cipher construct and dedicated hash function. Our focus is on dedicated function, which contains three aspects.
 MD4 Family  MD5 SHA-1 SHA-3  SHA-3 Others  Properties of Hash Function SHA-1 Overview The general idea for SHA-1 is to transfer the message with any length into 160 bits.</description>
    </item>
    
    <item>
      <title>Overview For Advanced Cryptography A</title>
      <link>https://yangzhanghavefun.github.io/yzzhan/post/cryptography_and_security/</link>
      <pubDate>Fri, 11 Jan 2019 01:37:56 +0800</pubDate>
      
      <guid>https://yangzhanghavefun.github.io/yzzhan/post/cryptography_and_security/</guid>
      <description>This is the overview about what I have done related with Cryptography and Security. Here I have introduced the algorithm for SHA-1 and SHA-3.
The corresponding pages shows below. -SHA-1/SHA-3 : Algorithms for Hash Function</description>
    </item>
    
    <item>
      <title>Overview For Advanced Python Design Knowledge</title>
      <link>https://yangzhanghavefun.github.io/yzzhan/post/python/</link>
      <pubDate>Fri, 11 Jan 2019 01:37:56 +0800</pubDate>
      
      <guid>https://yangzhanghavefun.github.io/yzzhan/post/python/</guid>
      <description> This is the Abstract Page for Python relative knowledge, which could be separated into four part: 1. Django : 2. Advanced Python Understanding : ### Toroutine : [Coroutine](https://yangzhanghavefun.github.io/yzzhan/post/coroutine/) ### Asyncio : ### Multithreading: [Multithreading and Future object](https://yangzhanghavefun.github.io/yzzhan/post/multithreads/) ### base class : ### Properties : ### iterator and generator: [Iterator, Generator and Basic understanding of Coroutine](https://yangzhanghavefun.github.io/yzzhan/post/generator/)  3. Tornado : 4. Search Engine Design : </description>
    </item>
    
    <item>
      <title>Creating a New Theme</title>
      <link>https://yangzhanghavefun.github.io/yzzhan/post/creating-a-new-theme/</link>
      <pubDate>Sun, 28 Sep 2014 00:00:00 +0000</pubDate>
      
      <guid>https://yangzhanghavefun.github.io/yzzhan/post/creating-a-new-theme/</guid>
      <description>Introduction This tutorial will show you how to create a simple theme in Hugo. I assume that you are familiar with HTML, the bash command line, and that you are comfortable using Markdown to format content. I&amp;rsquo;ll explain how Hugo uses templates and how you can organize your templates to create a theme. I won&amp;rsquo;t cover using CSS to style your theme.
We&amp;rsquo;ll start with creating a new site with a very basic template.</description>
    </item>
    
    <item>
      <title>(Hu)go Template Primer</title>
      <link>https://yangzhanghavefun.github.io/yzzhan/post/goisforlovers/</link>
      <pubDate>Mon, 28 Jul 2014 00:00:00 +0000</pubDate>
      
      <guid>https://yangzhanghavefun.github.io/yzzhan/post/goisforlovers/</guid>
      <description>Hugo uses the excellent go html/template library for its template engine. It is an extremely lightweight engine that provides a very small amount of logic. In our experience that it is just the right amount of logic to be able to create a good static website. If you have used other template systems from different languages or frameworks you will find a lot of similarities in go templates.
This document is a brief primer on using go templates.</description>
    </item>
    
    <item>
      <title>Hugo 主题 Nuo 文章样式预览</title>
      <link>https://yangzhanghavefun.github.io/yzzhan/post/hugo-nuo-post-preview/</link>
      <pubDate>Thu, 17 Jul 2014 00:00:00 +0000</pubDate>
      
      <guid>https://yangzhanghavefun.github.io/yzzhan/post/hugo-nuo-post-preview/</guid>
      <description>&lt;p&gt;这篇文章集中说明本人博客主题所支持的 Markdown 语法和 Hugo Shortcodes 插件，你也可以在这里预览到他们的样子。如果你不喜欢某些部分的样式，可以去修改 &lt;code&gt;content.scss&lt;/code&gt; 和 &lt;code&gt;shortcodes.scss&lt;/code&gt; 这两个文件。预告一下，我所用的这个名为 &lt;code&gt;Nuo&lt;/code&gt; 的 &lt;code&gt;Hugo&lt;/code&gt; 也将于近期发布，敬请期待。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Getting Started with Hugo</title>
      <link>https://yangzhanghavefun.github.io/yzzhan/post/hugoisforlovers/</link>
      <pubDate>Wed, 02 Apr 2014 00:00:00 +0000</pubDate>
      
      <guid>https://yangzhanghavefun.github.io/yzzhan/post/hugoisforlovers/</guid>
      <description>Step 1. Install Hugo Goto hugo releases and download the appropriate version for your os and architecture.
Save it somewhere specific as we will be using it in the next step.
More complete instructions are available at installing hugo
Step 2. Build the Docs Hugo has its own example site which happens to also be the documentation site you are reading right now.
Follow the following steps:
 Clone the hugo repository Go into the repo Run hugo in server mode and build the docs Open your browser to http://localhost:1313  Corresponding pseudo commands:</description>
    </item>
    
    <item>
      <title>Migrate to Hugo from Jekyll</title>
      <link>https://yangzhanghavefun.github.io/yzzhan/post/migrate-from-jekyll/</link>
      <pubDate>Mon, 10 Mar 2014 00:00:00 +0000</pubDate>
      
      <guid>https://yangzhanghavefun.github.io/yzzhan/post/migrate-from-jekyll/</guid>
      <description>Move static content to static Jekyll has a rule that any directory not starting with _ will be copied as-is to the _site output. Hugo keeps all static content under static. You should therefore move it all there. With Jekyll, something that looked like
▾ &amp;lt;root&amp;gt;/ ▾ images/ logo.png  should become
▾ &amp;lt;root&amp;gt;/ ▾ static/ ▾ images/ logo.png  Additionally, you&amp;rsquo;ll want any files that should reside at the root (such as CNAME) to be moved to static.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://yangzhanghavefun.github.io/yzzhan/post/ai_planing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yangzhanghavefun.github.io/yzzhan/post/ai_planing/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://yangzhanghavefun.github.io/yzzhan/post/iteratorandgenerator/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yangzhanghavefun.github.io/yzzhan/post/iteratorandgenerator/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>