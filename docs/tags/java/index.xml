<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java on Yzzhan Tech Repo</title>
    <link>https://yangzhanghavefun.github.io/yzzhan/tags/java/</link>
    <description>Recent content in Java on Yzzhan Tech Repo</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>© This post is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License，please give source if you wish to quote or reproduce.</copyright>
    <lastBuildDate>Tue, 04 Jun 2019 01:37:56 +0800</lastBuildDate>
    
	<atom:link href="https://yangzhanghavefun.github.io/yzzhan/tags/java/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>深入理解java并发知识的归纳</title>
      <link>https://yangzhanghavefun.github.io/yzzhan/post/javaconcurrency/</link>
      <pubDate>Tue, 04 Jun 2019 01:37:56 +0800</pubDate>
      
      <guid>https://yangzhanghavefun.github.io/yzzhan/post/javaconcurrency/</guid>
      <description>1. 多线程基础  1.1. 多线程的三个问题 1.2. Java内存模型 1.3. 如果解决并发原子性问题&amp;mdash;互斥锁 1.4. &amp;ldquo;等待-通知&amp;rdquo;机制 1.5. 编程中需要注意的三类问题: 安全性问题, 活跃性问题和性能问题. 1.6. 管程 1.7. 线程 1.8. 并发量 1.9. 局部变量 &amp;ndash; 线程封闭  2. Java.util.Concurrent JUC并发包详解  2.1. Lock接口 2.2. Condition接口 2.3. 信号量模型 2.4. ReadWriteLock 实现 2.5. StampedLock 2.6. CountDownLatch和CyclicBarrier 2.7. 并发容器 2.8. 原子类 2.9. 线程池Executor 2.10. Future 2.11. CompletableFuture 2.12. CompletionService: 批量异步化操作 2.13. Fork/Join 分治模型  并发设计模式  Immutability模式 Copy-on-Write模式 线程本地存储模式 Guarded Suspension模式 Balking模式 Thread-Per-Message模式 Worker Thread模式 两阶段终止模式 生产者消费者模式  实际并发框架的简要分析  Guava RateLimiter 高性能限流器 Netty 高性能网络应用框架 Disruptor 高性能队列 HiKariCP 高性能数据库连接池   1.</description>
    </item>
    
    <item>
      <title>深入理解java网络开发知识的归纳</title>
      <link>https://yangzhanghavefun.github.io/yzzhan/post/javawebknowledge/</link>
      <pubDate>Tue, 04 Jun 2019 01:37:56 +0800</pubDate>
      
      <guid>https://yangzhanghavefun.github.io/yzzhan/post/javawebknowledge/</guid>
      <description>JSP and Serverlet Spring Family Spring Framework Bean AOP @Aspect public class LoggingAspect { @Before(&amp;#34;execution(public String getName())&amp;#34;) public void LoggingAdvice(){ System.out.println(&amp;#34;LOG: Get method called.&amp;#34;); } } 通过一个Aspect方法可以起到任何类调用他们自己的public String getName()方法之前都会调用LoggingAdvice()方法.
我们也可以创造一个切点,应用于其他的AOP方法
@Aspect public class LoggingAspect{ //切点执行前执行  @Before(&amp;#34;allGetters()&amp;#34;) public void LoggingAdvice() { System.out.println(&amp;#34;Advice run. Get Method called&amp;#34;); } //切点执行后执行  @After(&amp;#34;allGetters()&amp;#34;) public void LoggingAdvice() { System.out.println(&amp;#34;Advice run. Get Method called&amp;#34;); } //切点方法执行完成返回后再执行, 同时可以通过执行返回类型来限制  @AfterReturning(pointcut=&amp;#34;allGetters()&amp;#34;, returning=&amp;#34;returnString&amp;#34;) public void LoggingAdvice() { System.</description>
    </item>
    
    <item>
      <title>解析J.U.C源码</title>
      <link>https://yangzhanghavefun.github.io/yzzhan/post/juc_source/</link>
      <pubDate>Sun, 02 Jun 2019 01:37:56 +0800</pubDate>
      
      <guid>https://yangzhanghavefun.github.io/yzzhan/post/juc_source/</guid>
      <description> Atomic Classes Atomic包的实现主要依赖硬件原子指令CAS的支持.例如在getAndIncrement()方法中调用了unsafe.getAndAddInt()方法. 其中调用了native的compareAndSwapInt方法.
//例如要在并发环境中对count这个对象执行加一的操作,count原有指为5.  public final int getAndAddInt(Object var1, long var2, int var4) { //var1 指被操作的对象, var2指被操作对象的偏移量, var4值要加的值  //对应例子var1=count, var2=5, var4=1  int var5; do { //通过对象和offset得到内存中这个对象真正的值.  var5 = this.getIntVolatile(var1, var2); } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4)); 当内存中的值等于对应的偏移量(输入的值)时,执行值的交换操作. return var5; }</description>
    </item>
    
    <item>
      <title>对深入理解java虚拟机的读书总结</title>
      <link>https://yangzhanghavefun.github.io/yzzhan/post/jvm/</link>
      <pubDate>Mon, 13 May 2019 01:37:56 +0800</pubDate>
      
      <guid>https://yangzhanghavefun.github.io/yzzhan/post/jvm/</guid>
      <description>这篇文章是关于/&amp;lt;&amp;lt;深入理解Java虚拟机第二版&amp;gt;&amp;gt;的全书总结.总结的目录也与原书的章节吻合.
Part 1(Java 概括) Java技术体系的组成部分 - Java 程序设计语言 - 各种硬件平台上的Java虚拟机 - Class文件格式 - Java API 类库 - 来自商业机构和开源社区的第三方Java类库
JDK(Java Development Kit) 包括Java 程序设计语言, Java虚拟机, JavaAPI类库这三部分。是用于支持Java程序开发的最小环境
JRE(Java Runtime Environment) 包括Java SE API子集和Java虚拟机这两个部分。是支持Java程序运行的标准环境。
Java的四个平台 - Java Card: 支持一些Java小程序(Applets) 运行在小内存设备（如智能卡）上的平台 - Java ME(Micro Edition): 支持Java程序运行在移动终端上的平台，是对Java API有所精简并加入了针对移动终端支持，以前称为J2ME。 - Java SE（Standard Edition）: 支持面向桌面级应用。 - Java EE (Enterprise Edition) : 支持使用多层架构的企业应用的Java平台，除了提供Java SE API外，还对其做了大量的扩充和部署支持。
Part 2（自动内存管理机制） Java内存区域与内存溢出异常 运行时的数据区域 Java虚拟机在执行Java程序的过程中会把所管理的内存划分为若干个不同的数据区域. 1. 程序计数器(Program Counter Register) * 当前线程所执行的字节码的行号指示器 * 字节码解释器工作时通过程序计数器来选取下一条需要执行的字节码指令.</description>
    </item>
    
    <item>
      <title>Java知识点杂记</title>
      <link>https://yangzhanghavefun.github.io/yzzhan/post/javarandomnote/</link>
      <pubDate>Mon, 15 Apr 2019 01:37:56 +0800</pubDate>
      
      <guid>https://yangzhanghavefun.github.io/yzzhan/post/javarandomnote/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Data Structures and Algorithm in Java</title>
      <link>https://yangzhanghavefun.github.io/yzzhan/post/javadatastructureandalgorithm/</link>
      <pubDate>Fri, 12 Apr 2019 01:37:56 +0800</pubDate>
      
      <guid>https://yangzhanghavefun.github.io/yzzhan/post/javadatastructureandalgorithm/</guid>
      <description>Data Structure and Algorithm Iterators Suppose we want to traverse a list, performing some operations on certain links.
As users of a list, what we need is access to reference that can point to any arbitray link. This allows us to examine or modify the link. We should be able to increment the reference so we can traverse along the list, looking at each link in turn, and we should be able to access the link pointed to by the reference.</description>
    </item>
    
    <item>
      <title>Java拾遗</title>
      <link>https://yangzhanghavefun.github.io/yzzhan/post/javashiyi/</link>
      <pubDate>Tue, 02 Apr 2019 01:37:56 +0800</pubDate>
      
      <guid>https://yangzhanghavefun.github.io/yzzhan/post/javashiyi/</guid>
      <description>面向对象和面向过程的区别与面向对象的三大基本特征和五大基本原则 面向过程指把task分解成一个一个的步骤, 每个步骤用函数来实现,依次调用即可.
进一步解释:在软件开发初期,程序编写都是以算法为核心,程序员会把数据和过程分别作为独立的部分来考虑, 数据代表空间中的客体,程序代码则用于处理这些数据,这种直接站在计算机的角度去抽象问题和解决问题的思想称为面向过程的编程思想.
面向对象指把task分解成一个一个的步骤之后, 并对各个步骤进行相应的抽象, 形成对象, 同时建立对象之间的联系. 随后组合解决问题. 在面向对象编程的过程中,要把步骤进行相应的抽象形成对象, 对象封装了相应的属性和方法. 最后基于对象和对象的能力来完成业务逻辑的实现.
进一步解释:面向对象的编程思想是站在现实角度去抽象和解决问题,它把数据和行为都看做是对象的一部分, 这样可以让程序员能以符合现实世界的思维方式来编写和组织程序.
面向对象的三个基本特征 - 封装 - 继承 - 多态 &amp;gt;封装(Encapsulation):是指利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体，数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。系统的其他对象只能通过包裹在数据外面的已经授权的操作来与这个封装的对象进行交流和交互。也就是说用户是无需知道对象内部的细节，但可以通过该对象对外的提供的接口来访问该对象。
 继承(Inheritance): 继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码，能够大大的提高开发的效率。 继承所描述的是“is-a”的关系，如果有两个对象A和B，若可以描述为“A是B”，则可以表示A继承B，其中B是被继承者称之为父类或者超类，A是继承者称之为子类或者派生类。
 《Think in java》：问一问自己是否需要从子类向父类进行向上转型。如果必须向上转型，则继承是必要的，但是如果不需要，则应当好好考虑自己是否需要继承。
 多态(Polymorphism): 所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。
 对于面向对象而言，多态分为编译时多态和运行时多态。其中编辑时多态是静态的，主要是指方法的重载，它是根据参数列表的不同来区分不同的函数，通过编辑之后会变成两个不同的函数，在运行时谈不上多态。而运行时多态是动态的，它是通过动态绑定来实现的，也就是我们所说的多态性。
总结:OOP是一种编程思想,一种程序范式,提倡用类来实现对象,用继承来实现关系,用封装来实现类所提供的功能,用多态来实现角色的动态转换
原文：https://blog.csdn.net/jianyuerensheng/article/details/51602015
面向对象的五个基本原则 &amp;gt;单一职责原则(Single-Resposibility Principle): 其核心思想为：一个类，最好只做一件事，只有一个引起它的变化。单一职责原则可以看做是低耦合、高内聚在面向对象原则上的引申，将职责定义为引起变化的原因，以提高内聚性来减少引起变化的原因。职责过多，可能引起它变化的原因就越多，这将导致职责依赖，相互之间就产生影响，从而大大损伤其内聚性和耦合度。通常意义下的单一职责，就是指只有一种单一功能，不要为类实现过多的功能点，以保证实体只有一个引起它变化的原因。 专注，是一个人优良的品质；同样的，单一也是一个类的优良设计。交杂不清的职责将使得代码看起来特别别扭牵一发而动全身，有失美感和必然导致丑陋的系统错误风险。
 开放封闭原则(Open-Closed principle): 其核心思想是：软件实体应该是可扩展的，而不可修改的。也就是，对扩展开放，对修改封闭的。开放封闭原则主要体现在两个方面1、对扩展开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。2、对修改封闭，意味着类一旦设计完成，就可以独立完成其工作，而不要对其进行任何尝试的修改。 实现开开放封闭原则的核心思想就是对抽象编程，而不对具体编程，因为抽象相对稳定。让类依赖于固定的抽象，所以修改就是封闭的；而通过面向对象的继承和多态机制，又可以实现对抽象类的继承，通过覆写其方法来改变固有行为，实现新的拓展方法，所以就是开放的。 “需求总是变化”没有不变的软件，所以就需要用封闭开放原则来封闭变化满足需求，同时还能保持软件内部的封装体系稳定，不被需求的变化影响。
Liskov替换原则(Liskov-Substituion Principle): 其核心思想是：子类必须能够替换其基类。这一思想体现为对继承机制的约束规范，只有子类能够替换基类时，才能保证系统在运行期内识别子类，这是保证继承复用的基础。在父类和子类的具体行为中，必须严格把握继承层次中的关系和特征，将基类替换为子类，程序的行为不会发生任何变化。同时，这一约束反过来则是不成立的，子类可以替换基类，但是基类不一定能替换子类。 Liskov替换原则，主要着眼于对抽象和多态建立在继承的基础上，因此只有遵循了Liskov替换原则，才能保证继承复用是可靠地。实现的方法是面向接口编程：将公共部分抽象为基类接口或抽象类，通过Extract Abstract Class，在子类中通过覆写父类的方法实现新的方式支持同样的职责。 Liskov替换原则是关于继承机制的设计原则，违反了Liskov替换原则就必然导致违反开放封闭原则。 Liskov替换原则能够保证系统具有良好的拓展性，同时实现基于多态的抽象机制，能够减少代码冗余，避免运行期的类型判别。
依赖倒置原则(Dependecy-Inversion Principle): 其核心思想是：依赖于抽象。具体而言就是高层模块不依赖于底层模块，二者都同依赖于抽象；抽象不依赖于具体，具体依赖于抽象。 我们知道，依赖一定会存在于类与类、模块与模块之间。当两个模块之间存在紧密的耦合关系时，最好的方法就是分离接口和实现：在依赖之间定义一个抽象的接口使得高层模块调用接口，而底层模块实现接口的定义，以此来有效控制耦合关系，达到依赖于抽象的设计目标。 抽象的稳定性决定了系统的稳定性，因为抽象是不变的，依赖于抽象是面向对象设计的精髓，也是依赖倒置原则的核心。 依赖于抽象是一个通用的原则，而某些时候依赖于细节则是在所难免的，必须权衡在抽象和具体之间的取舍，方法不是一层不变的。依赖于抽象，就是对接口编程，不要对实现编程。
接口隔离原则(Interface-Segregation Principle): 其核心思想是：使用多个小的专门的接口，而不要使用一个大的总接口。 具体而言，接口隔离原则体现在：接口应该是内聚的，应该避免“胖”接口。一个类对另外一个类的依赖应该建立在最小的接口上，不要强迫依赖不用的方法，这是一种接口污染。 接口有效地将细节和抽象隔离，体现了对抽象编程的一切好处，接口隔离强调接口的单一性。而胖接口存在明显的弊端，会导致实现的类型必须完全实现接口的所有方法、属性等；而某些时候，实现类型并非需要所有的接口定义，在设计上这是“浪费”，而且在实施上这会带来潜在的问题，对胖接口的修改将导致一连串的客户端程序需要修改，有时候这是一种灾难。在这种情况下，将胖接口分解为多个特点的定制化方法，使得客户端仅仅依赖于它们的实际调用的方法，从而解除了客户端不会依赖于它们不用的方法。 分离的手段主要有以下两种：1、委托分离，通过增加一个新的类型来委托客户的请求，隔离客户和接口的直接依赖，但是会增加系统的开销。2、多重继承分离，通过接口多继承来实现客户的需求，这种方式是较好的。</description>
    </item>
    
    <item>
      <title>Java面试的知识储备</title>
      <link>https://yangzhanghavefun.github.io/yzzhan/post/java-interview-preparation/</link>
      <pubDate>Sat, 16 Mar 2019 01:37:56 +0800</pubDate>
      
      <guid>https://yangzhanghavefun.github.io/yzzhan/post/java-interview-preparation/</guid>
      <description>#Content 1. Difference between Hashtable and HashMap
1.Difference between Hashtable and HashMap  ### 作者不一样。。。  Hashtable阵容
* @author Arthur van Hoff * @author Josh Bloch * @author Neal Gafter HashMap阵容
* @author Arthur van Hoff * @author Josh Bloch * @author Neal Gafter * @author Doug Lea Doug Lea大神写了util.concurrent包。 并著有并发编程圣经Concurrent Programming in Java: Design Principles and Patterns 他的个人主页 http://g.oswego.edu/ Josh Bloch 著有Effective Java, Arthur vanHoff最早任职于硅谷的SunMicrosystems公司，从事Java程序语言的早期开发工作 Neal Gafter是Java SE 4和5语言增强的主要设计者和实现者</description>
    </item>
    
  </channel>
</rss>